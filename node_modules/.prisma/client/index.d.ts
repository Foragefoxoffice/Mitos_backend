
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model questionType
 * 
 */
export type questionType = $Result.DefaultSelection<Prisma.$questionTypePayload>
/**
 * Model portion
 * 
 */
export type portion = $Result.DefaultSelection<Prisma.$portionPayload>
/**
 * Model subject
 * 
 */
export type subject = $Result.DefaultSelection<Prisma.$subjectPayload>
/**
 * Model chapter
 * 
 */
export type chapter = $Result.DefaultSelection<Prisma.$chapterPayload>
/**
 * Model topic
 * 
 */
export type topic = $Result.DefaultSelection<Prisma.$topicPayload>
/**
 * Model question
 * 
 */
export type question = $Result.DefaultSelection<Prisma.$questionPayload>
/**
 * Model Pdf
 * 
 */
export type Pdf = $Result.DefaultSelection<Prisma.$PdfPayload>
/**
 * Model TestResult
 * 
 */
export type TestResult = $Result.DefaultSelection<Prisma.$TestResultPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionType`: Exposes CRUD operations for the **questionType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionTypes
    * const questionTypes = await prisma.questionType.findMany()
    * ```
    */
  get questionType(): Prisma.questionTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portion`: Exposes CRUD operations for the **portion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Portions
    * const portions = await prisma.portion.findMany()
    * ```
    */
  get portion(): Prisma.portionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.subjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapter`: Exposes CRUD operations for the **chapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapter.findMany()
    * ```
    */
  get chapter(): Prisma.chapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.topicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.questionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pdf`: Exposes CRUD operations for the **Pdf** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pdfs
    * const pdfs = await prisma.pdf.findMany()
    * ```
    */
  get pdf(): Prisma.PdfDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testResult`: Exposes CRUD operations for the **TestResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestResults
    * const testResults = await prisma.testResult.findMany()
    * ```
    */
  get testResult(): Prisma.TestResultDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.4.1
   * Query Engine version: a9055b89e58b4b5bfb59600785423b1db3d0e75d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    questionType: 'questionType',
    portion: 'portion',
    subject: 'subject',
    chapter: 'chapter',
    topic: 'topic',
    question: 'question',
    Pdf: 'Pdf',
    TestResult: 'TestResult'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "questionType" | "portion" | "subject" | "chapter" | "topic" | "question" | "pdf" | "testResult"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      questionType: {
        payload: Prisma.$questionTypePayload<ExtArgs>
        fields: Prisma.questionTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionTypePayload>
          }
          findFirst: {
            args: Prisma.questionTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionTypePayload>
          }
          findMany: {
            args: Prisma.questionTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionTypePayload>[]
          }
          create: {
            args: Prisma.questionTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionTypePayload>
          }
          createMany: {
            args: Prisma.questionTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questionTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionTypePayload>
          }
          update: {
            args: Prisma.questionTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionTypePayload>
          }
          deleteMany: {
            args: Prisma.questionTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questionTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questionTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionTypePayload>
          }
          aggregate: {
            args: Prisma.QuestionTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionType>
          }
          groupBy: {
            args: Prisma.questionTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.questionTypeCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionTypeCountAggregateOutputType> | number
          }
        }
      }
      portion: {
        payload: Prisma.$portionPayload<ExtArgs>
        fields: Prisma.portionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.portionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.portionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portionPayload>
          }
          findFirst: {
            args: Prisma.portionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.portionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portionPayload>
          }
          findMany: {
            args: Prisma.portionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portionPayload>[]
          }
          create: {
            args: Prisma.portionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portionPayload>
          }
          createMany: {
            args: Prisma.portionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.portionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portionPayload>
          }
          update: {
            args: Prisma.portionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portionPayload>
          }
          deleteMany: {
            args: Prisma.portionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.portionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.portionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portionPayload>
          }
          aggregate: {
            args: Prisma.PortionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortion>
          }
          groupBy: {
            args: Prisma.portionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortionGroupByOutputType>[]
          }
          count: {
            args: Prisma.portionCountArgs<ExtArgs>
            result: $Utils.Optional<PortionCountAggregateOutputType> | number
          }
        }
      }
      subject: {
        payload: Prisma.$subjectPayload<ExtArgs>
        fields: Prisma.subjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>
          }
          findFirst: {
            args: Prisma.subjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>
          }
          findMany: {
            args: Prisma.subjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>[]
          }
          create: {
            args: Prisma.subjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>
          }
          createMany: {
            args: Prisma.subjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>
          }
          update: {
            args: Prisma.subjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>
          }
          deleteMany: {
            args: Prisma.subjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.subjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.subjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      chapter: {
        payload: Prisma.$chapterPayload<ExtArgs>
        fields: Prisma.chapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>
          }
          findFirst: {
            args: Prisma.chapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>
          }
          findMany: {
            args: Prisma.chapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>[]
          }
          create: {
            args: Prisma.chapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>
          }
          createMany: {
            args: Prisma.chapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.chapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>
          }
          update: {
            args: Prisma.chapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>
          }
          deleteMany: {
            args: Prisma.chapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.chapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>
          }
          aggregate: {
            args: Prisma.ChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapter>
          }
          groupBy: {
            args: Prisma.chapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.chapterCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterCountAggregateOutputType> | number
          }
        }
      }
      topic: {
        payload: Prisma.$topicPayload<ExtArgs>
        fields: Prisma.topicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.topicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.topicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicPayload>
          }
          findFirst: {
            args: Prisma.topicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.topicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicPayload>
          }
          findMany: {
            args: Prisma.topicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicPayload>[]
          }
          create: {
            args: Prisma.topicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicPayload>
          }
          createMany: {
            args: Prisma.topicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.topicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicPayload>
          }
          update: {
            args: Prisma.topicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicPayload>
          }
          deleteMany: {
            args: Prisma.topicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.topicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.topicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.topicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.topicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      question: {
        payload: Prisma.$questionPayload<ExtArgs>
        fields: Prisma.questionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          findFirst: {
            args: Prisma.questionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          findMany: {
            args: Prisma.questionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>[]
          }
          create: {
            args: Prisma.questionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          createMany: {
            args: Prisma.questionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          update: {
            args: Prisma.questionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          deleteMany: {
            args: Prisma.questionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.questionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.questionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      Pdf: {
        payload: Prisma.$PdfPayload<ExtArgs>
        fields: Prisma.PdfFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PdfFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PdfFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfPayload>
          }
          findFirst: {
            args: Prisma.PdfFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PdfFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfPayload>
          }
          findMany: {
            args: Prisma.PdfFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfPayload>[]
          }
          create: {
            args: Prisma.PdfCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfPayload>
          }
          createMany: {
            args: Prisma.PdfCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PdfDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfPayload>
          }
          update: {
            args: Prisma.PdfUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfPayload>
          }
          deleteMany: {
            args: Prisma.PdfDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PdfUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PdfUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfPayload>
          }
          aggregate: {
            args: Prisma.PdfAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePdf>
          }
          groupBy: {
            args: Prisma.PdfGroupByArgs<ExtArgs>
            result: $Utils.Optional<PdfGroupByOutputType>[]
          }
          count: {
            args: Prisma.PdfCountArgs<ExtArgs>
            result: $Utils.Optional<PdfCountAggregateOutputType> | number
          }
        }
      }
      TestResult: {
        payload: Prisma.$TestResultPayload<ExtArgs>
        fields: Prisma.TestResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          findFirst: {
            args: Prisma.TestResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          findMany: {
            args: Prisma.TestResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>[]
          }
          create: {
            args: Prisma.TestResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          createMany: {
            args: Prisma.TestResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TestResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          update: {
            args: Prisma.TestResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          deleteMany: {
            args: Prisma.TestResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          aggregate: {
            args: Prisma.TestResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestResult>
          }
          groupBy: {
            args: Prisma.TestResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestResultCountArgs<ExtArgs>
            result: $Utils.Optional<TestResultCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    questionType?: questionTypeOmit
    portion?: portionOmit
    subject?: subjectOmit
    chapter?: chapterOmit
    topic?: topicOmit
    question?: questionOmit
    pdf?: PdfOmit
    testResult?: TestResultOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    testResults: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testResults?: boolean | UserCountOutputTypeCountTestResultsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestResultWhereInput
  }


  /**
   * Count Type QuestionTypeCountOutputType
   */

  export type QuestionTypeCountOutputType = {
    other_questionType: number
    question: number
  }

  export type QuestionTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_questionType?: boolean | QuestionTypeCountOutputTypeCountOther_questionTypeArgs
    question?: boolean | QuestionTypeCountOutputTypeCountQuestionArgs
  }

  // Custom InputTypes
  /**
   * QuestionTypeCountOutputType without action
   */
  export type QuestionTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTypeCountOutputType
     */
    select?: QuestionTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionTypeCountOutputType without action
   */
  export type QuestionTypeCountOutputTypeCountOther_questionTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionTypeWhereInput
  }

  /**
   * QuestionTypeCountOutputType without action
   */
  export type QuestionTypeCountOutputTypeCountQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionWhereInput
  }


  /**
   * Count Type PortionCountOutputType
   */

  export type PortionCountOutputType = {
    subjects: number
    questions: number
    pdfs: number
  }

  export type PortionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | PortionCountOutputTypeCountSubjectsArgs
    questions?: boolean | PortionCountOutputTypeCountQuestionsArgs
    pdfs?: boolean | PortionCountOutputTypeCountPdfsArgs
  }

  // Custom InputTypes
  /**
   * PortionCountOutputType without action
   */
  export type PortionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortionCountOutputType
     */
    select?: PortionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PortionCountOutputType without action
   */
  export type PortionCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subjectWhereInput
  }

  /**
   * PortionCountOutputType without action
   */
  export type PortionCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionWhereInput
  }

  /**
   * PortionCountOutputType without action
   */
  export type PortionCountOutputTypeCountPdfsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PdfWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    chapters: number
    questions: number
    pdfs: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | SubjectCountOutputTypeCountChaptersArgs
    questions?: boolean | SubjectCountOutputTypeCountQuestionsArgs
    pdfs?: boolean | SubjectCountOutputTypeCountPdfsArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chapterWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountPdfsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PdfWhereInput
  }


  /**
   * Count Type ChapterCountOutputType
   */

  export type ChapterCountOutputType = {
    questions: number
    pdfs: number
    topics: number
  }

  export type ChapterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | ChapterCountOutputTypeCountQuestionsArgs
    pdfs?: boolean | ChapterCountOutputTypeCountPdfsArgs
    topics?: boolean | ChapterCountOutputTypeCountTopicsArgs
  }

  // Custom InputTypes
  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterCountOutputType
     */
    select?: ChapterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountPdfsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PdfWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: topicWhereInput
  }


  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    questions: number
    pdfs: number
  }

  export type TopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | TopicCountOutputTypeCountQuestionsArgs
    pdfs?: boolean | TopicCountOutputTypeCountPdfsArgs
  }

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountPdfsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PdfWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    phoneNumber: string | null
    age: number | null
    gender: string | null
    profile: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    phoneNumber: string | null
    age: number | null
    gender: string | null
    profile: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    phoneNumber: number
    age: number
    gender: number
    profile: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    age?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    age?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    phoneNumber?: true
    age?: true
    gender?: true
    profile?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    phoneNumber?: true
    age?: true
    gender?: true
    profile?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    phoneNumber?: true
    age?: true
    gender?: true
    profile?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string | null
    password: string | null
    role: string
    createdAt: Date
    updatedAt: Date | null
    phoneNumber: string | null
    age: number | null
    gender: string | null
    profile: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phoneNumber?: boolean
    age?: boolean
    gender?: boolean
    profile?: boolean
    testResults?: boolean | User$testResultsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phoneNumber?: boolean
    age?: boolean
    gender?: boolean
    profile?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "role" | "createdAt" | "updatedAt" | "phoneNumber" | "age" | "gender" | "profile", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testResults?: boolean | User$testResultsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      testResults: Prisma.$TestResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string | null
      password: string | null
      role: string
      createdAt: Date
      updatedAt: Date | null
      phoneNumber: string | null
      age: number | null
      gender: string | null
      profile: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testResults<T extends User$testResultsArgs<ExtArgs> = {}>(args?: Subset<T, User$testResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly age: FieldRef<"User", 'Int'>
    readonly gender: FieldRef<"User", 'String'>
    readonly profile: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.testResults
   */
  export type User$testResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    where?: TestResultWhereInput
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    cursor?: TestResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestResultScalarFieldEnum | TestResultScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model questionType
   */

  export type AggregateQuestionType = {
    _count: QuestionTypeCountAggregateOutputType | null
    _avg: QuestionTypeAvgAggregateOutputType | null
    _sum: QuestionTypeSumAggregateOutputType | null
    _min: QuestionTypeMinAggregateOutputType | null
    _max: QuestionTypeMaxAggregateOutputType | null
  }

  export type QuestionTypeAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type QuestionTypeSumAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type QuestionTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    createdAt: Date | null
  }

  export type QuestionTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    createdAt: Date | null
  }

  export type QuestionTypeCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    createdAt: number
    _all: number
  }


  export type QuestionTypeAvgAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type QuestionTypeSumAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type QuestionTypeMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    createdAt?: true
  }

  export type QuestionTypeMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    createdAt?: true
  }

  export type QuestionTypeCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    createdAt?: true
    _all?: true
  }

  export type QuestionTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questionType to aggregate.
     */
    where?: questionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionTypes to fetch.
     */
    orderBy?: questionTypeOrderByWithRelationInput | questionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questionTypes
    **/
    _count?: true | QuestionTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionTypeMaxAggregateInputType
  }

  export type GetQuestionTypeAggregateType<T extends QuestionTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionType[P]>
      : GetScalarType<T[P], AggregateQuestionType[P]>
  }




  export type questionTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionTypeWhereInput
    orderBy?: questionTypeOrderByWithAggregationInput | questionTypeOrderByWithAggregationInput[]
    by: QuestionTypeScalarFieldEnum[] | QuestionTypeScalarFieldEnum
    having?: questionTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionTypeCountAggregateInputType | true
    _avg?: QuestionTypeAvgAggregateInputType
    _sum?: QuestionTypeSumAggregateInputType
    _min?: QuestionTypeMinAggregateInputType
    _max?: QuestionTypeMaxAggregateInputType
  }

  export type QuestionTypeGroupByOutputType = {
    id: number
    name: string
    parentId: number | null
    createdAt: Date
    _count: QuestionTypeCountAggregateOutputType | null
    _avg: QuestionTypeAvgAggregateOutputType | null
    _sum: QuestionTypeSumAggregateOutputType | null
    _min: QuestionTypeMinAggregateOutputType | null
    _max: QuestionTypeMaxAggregateOutputType | null
  }

  type GetQuestionTypeGroupByPayload<T extends questionTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionTypeGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionTypeGroupByOutputType[P]>
        }
      >
    >


  export type questionTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    createdAt?: boolean
    parent?: boolean | questionType$parentArgs<ExtArgs>
    other_questionType?: boolean | questionType$other_questionTypeArgs<ExtArgs>
    question?: boolean | questionType$questionArgs<ExtArgs>
    _count?: boolean | QuestionTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionType"]>



  export type questionTypeSelectScalar = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    createdAt?: boolean
  }

  export type questionTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "parentId" | "createdAt", ExtArgs["result"]["questionType"]>
  export type questionTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | questionType$parentArgs<ExtArgs>
    other_questionType?: boolean | questionType$other_questionTypeArgs<ExtArgs>
    question?: boolean | questionType$questionArgs<ExtArgs>
    _count?: boolean | QuestionTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $questionTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questionType"
    objects: {
      parent: Prisma.$questionTypePayload<ExtArgs> | null
      other_questionType: Prisma.$questionTypePayload<ExtArgs>[]
      question: Prisma.$questionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      parentId: number | null
      createdAt: Date
    }, ExtArgs["result"]["questionType"]>
    composites: {}
  }

  type questionTypeGetPayload<S extends boolean | null | undefined | questionTypeDefaultArgs> = $Result.GetResult<Prisma.$questionTypePayload, S>

  type questionTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<questionTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionTypeCountAggregateInputType | true
    }

  export interface questionTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questionType'], meta: { name: 'questionType' } }
    /**
     * Find zero or one QuestionType that matches the filter.
     * @param {questionTypeFindUniqueArgs} args - Arguments to find a QuestionType
     * @example
     * // Get one QuestionType
     * const questionType = await prisma.questionType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questionTypeFindUniqueArgs>(args: SelectSubset<T, questionTypeFindUniqueArgs<ExtArgs>>): Prisma__questionTypeClient<$Result.GetResult<Prisma.$questionTypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one QuestionType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {questionTypeFindUniqueOrThrowArgs} args - Arguments to find a QuestionType
     * @example
     * // Get one QuestionType
     * const questionType = await prisma.questionType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questionTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, questionTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questionTypeClient<$Result.GetResult<Prisma.$questionTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first QuestionType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionTypeFindFirstArgs} args - Arguments to find a QuestionType
     * @example
     * // Get one QuestionType
     * const questionType = await prisma.questionType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questionTypeFindFirstArgs>(args?: SelectSubset<T, questionTypeFindFirstArgs<ExtArgs>>): Prisma__questionTypeClient<$Result.GetResult<Prisma.$questionTypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first QuestionType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionTypeFindFirstOrThrowArgs} args - Arguments to find a QuestionType
     * @example
     * // Get one QuestionType
     * const questionType = await prisma.questionType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questionTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, questionTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__questionTypeClient<$Result.GetResult<Prisma.$questionTypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more QuestionTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionTypes
     * const questionTypes = await prisma.questionType.findMany()
     * 
     * // Get first 10 QuestionTypes
     * const questionTypes = await prisma.questionType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionTypeWithIdOnly = await prisma.questionType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questionTypeFindManyArgs>(args?: SelectSubset<T, questionTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionTypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a QuestionType.
     * @param {questionTypeCreateArgs} args - Arguments to create a QuestionType.
     * @example
     * // Create one QuestionType
     * const QuestionType = await prisma.questionType.create({
     *   data: {
     *     // ... data to create a QuestionType
     *   }
     * })
     * 
     */
    create<T extends questionTypeCreateArgs>(args: SelectSubset<T, questionTypeCreateArgs<ExtArgs>>): Prisma__questionTypeClient<$Result.GetResult<Prisma.$questionTypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many QuestionTypes.
     * @param {questionTypeCreateManyArgs} args - Arguments to create many QuestionTypes.
     * @example
     * // Create many QuestionTypes
     * const questionType = await prisma.questionType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questionTypeCreateManyArgs>(args?: SelectSubset<T, questionTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionType.
     * @param {questionTypeDeleteArgs} args - Arguments to delete one QuestionType.
     * @example
     * // Delete one QuestionType
     * const QuestionType = await prisma.questionType.delete({
     *   where: {
     *     // ... filter to delete one QuestionType
     *   }
     * })
     * 
     */
    delete<T extends questionTypeDeleteArgs>(args: SelectSubset<T, questionTypeDeleteArgs<ExtArgs>>): Prisma__questionTypeClient<$Result.GetResult<Prisma.$questionTypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one QuestionType.
     * @param {questionTypeUpdateArgs} args - Arguments to update one QuestionType.
     * @example
     * // Update one QuestionType
     * const questionType = await prisma.questionType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questionTypeUpdateArgs>(args: SelectSubset<T, questionTypeUpdateArgs<ExtArgs>>): Prisma__questionTypeClient<$Result.GetResult<Prisma.$questionTypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more QuestionTypes.
     * @param {questionTypeDeleteManyArgs} args - Arguments to filter QuestionTypes to delete.
     * @example
     * // Delete a few QuestionTypes
     * const { count } = await prisma.questionType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questionTypeDeleteManyArgs>(args?: SelectSubset<T, questionTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionTypes
     * const questionType = await prisma.questionType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questionTypeUpdateManyArgs>(args: SelectSubset<T, questionTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionType.
     * @param {questionTypeUpsertArgs} args - Arguments to update or create a QuestionType.
     * @example
     * // Update or create a QuestionType
     * const questionType = await prisma.questionType.upsert({
     *   create: {
     *     // ... data to create a QuestionType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionType we want to update
     *   }
     * })
     */
    upsert<T extends questionTypeUpsertArgs>(args: SelectSubset<T, questionTypeUpsertArgs<ExtArgs>>): Prisma__questionTypeClient<$Result.GetResult<Prisma.$questionTypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of QuestionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionTypeCountArgs} args - Arguments to filter QuestionTypes to count.
     * @example
     * // Count the number of QuestionTypes
     * const count = await prisma.questionType.count({
     *   where: {
     *     // ... the filter for the QuestionTypes we want to count
     *   }
     * })
    **/
    count<T extends questionTypeCountArgs>(
      args?: Subset<T, questionTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionTypeAggregateArgs>(args: Subset<T, QuestionTypeAggregateArgs>): Prisma.PrismaPromise<GetQuestionTypeAggregateType<T>>

    /**
     * Group by QuestionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionTypeGroupByArgs['orderBy'] }
        : { orderBy?: questionTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questionType model
   */
  readonly fields: questionTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questionType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends questionType$parentArgs<ExtArgs> = {}>(args?: Subset<T, questionType$parentArgs<ExtArgs>>): Prisma__questionTypeClient<$Result.GetResult<Prisma.$questionTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    other_questionType<T extends questionType$other_questionTypeArgs<ExtArgs> = {}>(args?: Subset<T, questionType$other_questionTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionTypePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    question<T extends questionType$questionArgs<ExtArgs> = {}>(args?: Subset<T, questionType$questionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questionType model
   */ 
  interface questionTypeFieldRefs {
    readonly id: FieldRef<"questionType", 'Int'>
    readonly name: FieldRef<"questionType", 'String'>
    readonly parentId: FieldRef<"questionType", 'Int'>
    readonly createdAt: FieldRef<"questionType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * questionType findUnique
   */
  export type questionTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionType
     */
    select?: questionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionType
     */
    omit?: questionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionTypeInclude<ExtArgs> | null
    /**
     * Filter, which questionType to fetch.
     */
    where: questionTypeWhereUniqueInput
  }

  /**
   * questionType findUniqueOrThrow
   */
  export type questionTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionType
     */
    select?: questionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionType
     */
    omit?: questionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionTypeInclude<ExtArgs> | null
    /**
     * Filter, which questionType to fetch.
     */
    where: questionTypeWhereUniqueInput
  }

  /**
   * questionType findFirst
   */
  export type questionTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionType
     */
    select?: questionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionType
     */
    omit?: questionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionTypeInclude<ExtArgs> | null
    /**
     * Filter, which questionType to fetch.
     */
    where?: questionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionTypes to fetch.
     */
    orderBy?: questionTypeOrderByWithRelationInput | questionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questionTypes.
     */
    cursor?: questionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questionTypes.
     */
    distinct?: QuestionTypeScalarFieldEnum | QuestionTypeScalarFieldEnum[]
  }

  /**
   * questionType findFirstOrThrow
   */
  export type questionTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionType
     */
    select?: questionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionType
     */
    omit?: questionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionTypeInclude<ExtArgs> | null
    /**
     * Filter, which questionType to fetch.
     */
    where?: questionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionTypes to fetch.
     */
    orderBy?: questionTypeOrderByWithRelationInput | questionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questionTypes.
     */
    cursor?: questionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questionTypes.
     */
    distinct?: QuestionTypeScalarFieldEnum | QuestionTypeScalarFieldEnum[]
  }

  /**
   * questionType findMany
   */
  export type questionTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionType
     */
    select?: questionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionType
     */
    omit?: questionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionTypeInclude<ExtArgs> | null
    /**
     * Filter, which questionTypes to fetch.
     */
    where?: questionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionTypes to fetch.
     */
    orderBy?: questionTypeOrderByWithRelationInput | questionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questionTypes.
     */
    cursor?: questionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionTypes.
     */
    skip?: number
    distinct?: QuestionTypeScalarFieldEnum | QuestionTypeScalarFieldEnum[]
  }

  /**
   * questionType create
   */
  export type questionTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionType
     */
    select?: questionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionType
     */
    omit?: questionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a questionType.
     */
    data: XOR<questionTypeCreateInput, questionTypeUncheckedCreateInput>
  }

  /**
   * questionType createMany
   */
  export type questionTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questionTypes.
     */
    data: questionTypeCreateManyInput | questionTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * questionType update
   */
  export type questionTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionType
     */
    select?: questionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionType
     */
    omit?: questionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a questionType.
     */
    data: XOR<questionTypeUpdateInput, questionTypeUncheckedUpdateInput>
    /**
     * Choose, which questionType to update.
     */
    where: questionTypeWhereUniqueInput
  }

  /**
   * questionType updateMany
   */
  export type questionTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questionTypes.
     */
    data: XOR<questionTypeUpdateManyMutationInput, questionTypeUncheckedUpdateManyInput>
    /**
     * Filter which questionTypes to update
     */
    where?: questionTypeWhereInput
    /**
     * Limit how many questionTypes to update.
     */
    limit?: number
  }

  /**
   * questionType upsert
   */
  export type questionTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionType
     */
    select?: questionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionType
     */
    omit?: questionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the questionType to update in case it exists.
     */
    where: questionTypeWhereUniqueInput
    /**
     * In case the questionType found by the `where` argument doesn't exist, create a new questionType with this data.
     */
    create: XOR<questionTypeCreateInput, questionTypeUncheckedCreateInput>
    /**
     * In case the questionType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionTypeUpdateInput, questionTypeUncheckedUpdateInput>
  }

  /**
   * questionType delete
   */
  export type questionTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionType
     */
    select?: questionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionType
     */
    omit?: questionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionTypeInclude<ExtArgs> | null
    /**
     * Filter which questionType to delete.
     */
    where: questionTypeWhereUniqueInput
  }

  /**
   * questionType deleteMany
   */
  export type questionTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questionTypes to delete
     */
    where?: questionTypeWhereInput
    /**
     * Limit how many questionTypes to delete.
     */
    limit?: number
  }

  /**
   * questionType.parent
   */
  export type questionType$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionType
     */
    select?: questionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionType
     */
    omit?: questionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionTypeInclude<ExtArgs> | null
    where?: questionTypeWhereInput
  }

  /**
   * questionType.other_questionType
   */
  export type questionType$other_questionTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionType
     */
    select?: questionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionType
     */
    omit?: questionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionTypeInclude<ExtArgs> | null
    where?: questionTypeWhereInput
    orderBy?: questionTypeOrderByWithRelationInput | questionTypeOrderByWithRelationInput[]
    cursor?: questionTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionTypeScalarFieldEnum | QuestionTypeScalarFieldEnum[]
  }

  /**
   * questionType.question
   */
  export type questionType$questionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    where?: questionWhereInput
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    cursor?: questionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * questionType without action
   */
  export type questionTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionType
     */
    select?: questionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionType
     */
    omit?: questionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionTypeInclude<ExtArgs> | null
  }


  /**
   * Model portion
   */

  export type AggregatePortion = {
    _count: PortionCountAggregateOutputType | null
    _avg: PortionAvgAggregateOutputType | null
    _sum: PortionSumAggregateOutputType | null
    _min: PortionMinAggregateOutputType | null
    _max: PortionMaxAggregateOutputType | null
  }

  export type PortionAvgAggregateOutputType = {
    id: number | null
  }

  export type PortionSumAggregateOutputType = {
    id: number | null
  }

  export type PortionMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type PortionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type PortionCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type PortionAvgAggregateInputType = {
    id?: true
  }

  export type PortionSumAggregateInputType = {
    id?: true
  }

  export type PortionMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type PortionMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type PortionCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type PortionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which portion to aggregate.
     */
    where?: portionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portions to fetch.
     */
    orderBy?: portionOrderByWithRelationInput | portionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: portionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned portions
    **/
    _count?: true | PortionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PortionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PortionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortionMaxAggregateInputType
  }

  export type GetPortionAggregateType<T extends PortionAggregateArgs> = {
        [P in keyof T & keyof AggregatePortion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortion[P]>
      : GetScalarType<T[P], AggregatePortion[P]>
  }




  export type portionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: portionWhereInput
    orderBy?: portionOrderByWithAggregationInput | portionOrderByWithAggregationInput[]
    by: PortionScalarFieldEnum[] | PortionScalarFieldEnum
    having?: portionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortionCountAggregateInputType | true
    _avg?: PortionAvgAggregateInputType
    _sum?: PortionSumAggregateInputType
    _min?: PortionMinAggregateInputType
    _max?: PortionMaxAggregateInputType
  }

  export type PortionGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    _count: PortionCountAggregateOutputType | null
    _avg: PortionAvgAggregateOutputType | null
    _sum: PortionSumAggregateOutputType | null
    _min: PortionMinAggregateOutputType | null
    _max: PortionMaxAggregateOutputType | null
  }

  type GetPortionGroupByPayload<T extends portionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortionGroupByOutputType[P]>
            : GetScalarType<T[P], PortionGroupByOutputType[P]>
        }
      >
    >


  export type portionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    subjects?: boolean | portion$subjectsArgs<ExtArgs>
    questions?: boolean | portion$questionsArgs<ExtArgs>
    pdfs?: boolean | portion$pdfsArgs<ExtArgs>
    _count?: boolean | PortionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portion"]>



  export type portionSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type portionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt", ExtArgs["result"]["portion"]>
  export type portionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | portion$subjectsArgs<ExtArgs>
    questions?: boolean | portion$questionsArgs<ExtArgs>
    pdfs?: boolean | portion$pdfsArgs<ExtArgs>
    _count?: boolean | PortionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $portionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "portion"
    objects: {
      subjects: Prisma.$subjectPayload<ExtArgs>[]
      questions: Prisma.$questionPayload<ExtArgs>[]
      pdfs: Prisma.$PdfPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
    }, ExtArgs["result"]["portion"]>
    composites: {}
  }

  type portionGetPayload<S extends boolean | null | undefined | portionDefaultArgs> = $Result.GetResult<Prisma.$portionPayload, S>

  type portionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<portionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortionCountAggregateInputType | true
    }

  export interface portionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['portion'], meta: { name: 'portion' } }
    /**
     * Find zero or one Portion that matches the filter.
     * @param {portionFindUniqueArgs} args - Arguments to find a Portion
     * @example
     * // Get one Portion
     * const portion = await prisma.portion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends portionFindUniqueArgs>(args: SelectSubset<T, portionFindUniqueArgs<ExtArgs>>): Prisma__portionClient<$Result.GetResult<Prisma.$portionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Portion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {portionFindUniqueOrThrowArgs} args - Arguments to find a Portion
     * @example
     * // Get one Portion
     * const portion = await prisma.portion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends portionFindUniqueOrThrowArgs>(args: SelectSubset<T, portionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__portionClient<$Result.GetResult<Prisma.$portionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Portion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portionFindFirstArgs} args - Arguments to find a Portion
     * @example
     * // Get one Portion
     * const portion = await prisma.portion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends portionFindFirstArgs>(args?: SelectSubset<T, portionFindFirstArgs<ExtArgs>>): Prisma__portionClient<$Result.GetResult<Prisma.$portionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Portion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portionFindFirstOrThrowArgs} args - Arguments to find a Portion
     * @example
     * // Get one Portion
     * const portion = await prisma.portion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends portionFindFirstOrThrowArgs>(args?: SelectSubset<T, portionFindFirstOrThrowArgs<ExtArgs>>): Prisma__portionClient<$Result.GetResult<Prisma.$portionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Portions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portions
     * const portions = await prisma.portion.findMany()
     * 
     * // Get first 10 Portions
     * const portions = await prisma.portion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portionWithIdOnly = await prisma.portion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends portionFindManyArgs>(args?: SelectSubset<T, portionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$portionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Portion.
     * @param {portionCreateArgs} args - Arguments to create a Portion.
     * @example
     * // Create one Portion
     * const Portion = await prisma.portion.create({
     *   data: {
     *     // ... data to create a Portion
     *   }
     * })
     * 
     */
    create<T extends portionCreateArgs>(args: SelectSubset<T, portionCreateArgs<ExtArgs>>): Prisma__portionClient<$Result.GetResult<Prisma.$portionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Portions.
     * @param {portionCreateManyArgs} args - Arguments to create many Portions.
     * @example
     * // Create many Portions
     * const portion = await prisma.portion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends portionCreateManyArgs>(args?: SelectSubset<T, portionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Portion.
     * @param {portionDeleteArgs} args - Arguments to delete one Portion.
     * @example
     * // Delete one Portion
     * const Portion = await prisma.portion.delete({
     *   where: {
     *     // ... filter to delete one Portion
     *   }
     * })
     * 
     */
    delete<T extends portionDeleteArgs>(args: SelectSubset<T, portionDeleteArgs<ExtArgs>>): Prisma__portionClient<$Result.GetResult<Prisma.$portionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Portion.
     * @param {portionUpdateArgs} args - Arguments to update one Portion.
     * @example
     * // Update one Portion
     * const portion = await prisma.portion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends portionUpdateArgs>(args: SelectSubset<T, portionUpdateArgs<ExtArgs>>): Prisma__portionClient<$Result.GetResult<Prisma.$portionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Portions.
     * @param {portionDeleteManyArgs} args - Arguments to filter Portions to delete.
     * @example
     * // Delete a few Portions
     * const { count } = await prisma.portion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends portionDeleteManyArgs>(args?: SelectSubset<T, portionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portions
     * const portion = await prisma.portion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends portionUpdateManyArgs>(args: SelectSubset<T, portionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Portion.
     * @param {portionUpsertArgs} args - Arguments to update or create a Portion.
     * @example
     * // Update or create a Portion
     * const portion = await prisma.portion.upsert({
     *   create: {
     *     // ... data to create a Portion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portion we want to update
     *   }
     * })
     */
    upsert<T extends portionUpsertArgs>(args: SelectSubset<T, portionUpsertArgs<ExtArgs>>): Prisma__portionClient<$Result.GetResult<Prisma.$portionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Portions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portionCountArgs} args - Arguments to filter Portions to count.
     * @example
     * // Count the number of Portions
     * const count = await prisma.portion.count({
     *   where: {
     *     // ... the filter for the Portions we want to count
     *   }
     * })
    **/
    count<T extends portionCountArgs>(
      args?: Subset<T, portionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Portion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortionAggregateArgs>(args: Subset<T, PortionAggregateArgs>): Prisma.PrismaPromise<GetPortionAggregateType<T>>

    /**
     * Group by Portion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends portionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: portionGroupByArgs['orderBy'] }
        : { orderBy?: portionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, portionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the portion model
   */
  readonly fields: portionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for portion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__portionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subjects<T extends portion$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, portion$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    questions<T extends portion$questionsArgs<ExtArgs> = {}>(args?: Subset<T, portion$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    pdfs<T extends portion$pdfsArgs<ExtArgs> = {}>(args?: Subset<T, portion$pdfsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdfPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the portion model
   */ 
  interface portionFieldRefs {
    readonly id: FieldRef<"portion", 'Int'>
    readonly name: FieldRef<"portion", 'String'>
    readonly createdAt: FieldRef<"portion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * portion findUnique
   */
  export type portionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portion
     */
    select?: portionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portion
     */
    omit?: portionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portionInclude<ExtArgs> | null
    /**
     * Filter, which portion to fetch.
     */
    where: portionWhereUniqueInput
  }

  /**
   * portion findUniqueOrThrow
   */
  export type portionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portion
     */
    select?: portionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portion
     */
    omit?: portionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portionInclude<ExtArgs> | null
    /**
     * Filter, which portion to fetch.
     */
    where: portionWhereUniqueInput
  }

  /**
   * portion findFirst
   */
  export type portionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portion
     */
    select?: portionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portion
     */
    omit?: portionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portionInclude<ExtArgs> | null
    /**
     * Filter, which portion to fetch.
     */
    where?: portionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portions to fetch.
     */
    orderBy?: portionOrderByWithRelationInput | portionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for portions.
     */
    cursor?: portionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of portions.
     */
    distinct?: PortionScalarFieldEnum | PortionScalarFieldEnum[]
  }

  /**
   * portion findFirstOrThrow
   */
  export type portionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portion
     */
    select?: portionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portion
     */
    omit?: portionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portionInclude<ExtArgs> | null
    /**
     * Filter, which portion to fetch.
     */
    where?: portionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portions to fetch.
     */
    orderBy?: portionOrderByWithRelationInput | portionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for portions.
     */
    cursor?: portionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of portions.
     */
    distinct?: PortionScalarFieldEnum | PortionScalarFieldEnum[]
  }

  /**
   * portion findMany
   */
  export type portionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portion
     */
    select?: portionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portion
     */
    omit?: portionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portionInclude<ExtArgs> | null
    /**
     * Filter, which portions to fetch.
     */
    where?: portionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portions to fetch.
     */
    orderBy?: portionOrderByWithRelationInput | portionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing portions.
     */
    cursor?: portionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portions.
     */
    skip?: number
    distinct?: PortionScalarFieldEnum | PortionScalarFieldEnum[]
  }

  /**
   * portion create
   */
  export type portionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portion
     */
    select?: portionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portion
     */
    omit?: portionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portionInclude<ExtArgs> | null
    /**
     * The data needed to create a portion.
     */
    data: XOR<portionCreateInput, portionUncheckedCreateInput>
  }

  /**
   * portion createMany
   */
  export type portionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many portions.
     */
    data: portionCreateManyInput | portionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * portion update
   */
  export type portionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portion
     */
    select?: portionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portion
     */
    omit?: portionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portionInclude<ExtArgs> | null
    /**
     * The data needed to update a portion.
     */
    data: XOR<portionUpdateInput, portionUncheckedUpdateInput>
    /**
     * Choose, which portion to update.
     */
    where: portionWhereUniqueInput
  }

  /**
   * portion updateMany
   */
  export type portionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update portions.
     */
    data: XOR<portionUpdateManyMutationInput, portionUncheckedUpdateManyInput>
    /**
     * Filter which portions to update
     */
    where?: portionWhereInput
    /**
     * Limit how many portions to update.
     */
    limit?: number
  }

  /**
   * portion upsert
   */
  export type portionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portion
     */
    select?: portionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portion
     */
    omit?: portionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portionInclude<ExtArgs> | null
    /**
     * The filter to search for the portion to update in case it exists.
     */
    where: portionWhereUniqueInput
    /**
     * In case the portion found by the `where` argument doesn't exist, create a new portion with this data.
     */
    create: XOR<portionCreateInput, portionUncheckedCreateInput>
    /**
     * In case the portion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<portionUpdateInput, portionUncheckedUpdateInput>
  }

  /**
   * portion delete
   */
  export type portionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portion
     */
    select?: portionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portion
     */
    omit?: portionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portionInclude<ExtArgs> | null
    /**
     * Filter which portion to delete.
     */
    where: portionWhereUniqueInput
  }

  /**
   * portion deleteMany
   */
  export type portionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which portions to delete
     */
    where?: portionWhereInput
    /**
     * Limit how many portions to delete.
     */
    limit?: number
  }

  /**
   * portion.subjects
   */
  export type portion$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    where?: subjectWhereInput
    orderBy?: subjectOrderByWithRelationInput | subjectOrderByWithRelationInput[]
    cursor?: subjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * portion.questions
   */
  export type portion$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    where?: questionWhereInput
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    cursor?: questionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * portion.pdfs
   */
  export type portion$pdfsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
    where?: PdfWhereInput
    orderBy?: PdfOrderByWithRelationInput | PdfOrderByWithRelationInput[]
    cursor?: PdfWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PdfScalarFieldEnum | PdfScalarFieldEnum[]
  }

  /**
   * portion without action
   */
  export type portionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portion
     */
    select?: portionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portion
     */
    omit?: portionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portionInclude<ExtArgs> | null
  }


  /**
   * Model subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectAvgAggregateOutputType = {
    id: number | null
    portionId: number | null
  }

  export type SubjectSumAggregateOutputType = {
    id: number | null
    portionId: number | null
  }

  export type SubjectMinAggregateOutputType = {
    id: number | null
    name: string | null
    portionId: number | null
    createdAt: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: number | null
    name: string | null
    portionId: number | null
    createdAt: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    name: number
    portionId: number
    createdAt: number
    _all: number
  }


  export type SubjectAvgAggregateInputType = {
    id?: true
    portionId?: true
  }

  export type SubjectSumAggregateInputType = {
    id?: true
    portionId?: true
  }

  export type SubjectMinAggregateInputType = {
    id?: true
    name?: true
    portionId?: true
    createdAt?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    name?: true
    portionId?: true
    createdAt?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    name?: true
    portionId?: true
    createdAt?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subject to aggregate.
     */
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectOrderByWithRelationInput | subjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type subjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subjectWhereInput
    orderBy?: subjectOrderByWithAggregationInput | subjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: subjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _avg?: SubjectAvgAggregateInputType
    _sum?: SubjectSumAggregateInputType
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: number
    name: string
    portionId: number
    createdAt: Date
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends subjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type subjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    portionId?: boolean
    createdAt?: boolean
    chapters?: boolean | subject$chaptersArgs<ExtArgs>
    questions?: boolean | subject$questionsArgs<ExtArgs>
    pdfs?: boolean | subject$pdfsArgs<ExtArgs>
    portion?: boolean | portionDefaultArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>



  export type subjectSelectScalar = {
    id?: boolean
    name?: boolean
    portionId?: boolean
    createdAt?: boolean
  }

  export type subjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "portionId" | "createdAt", ExtArgs["result"]["subject"]>
  export type subjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | subject$chaptersArgs<ExtArgs>
    questions?: boolean | subject$questionsArgs<ExtArgs>
    pdfs?: boolean | subject$pdfsArgs<ExtArgs>
    portion?: boolean | portionDefaultArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $subjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subject"
    objects: {
      chapters: Prisma.$chapterPayload<ExtArgs>[]
      questions: Prisma.$questionPayload<ExtArgs>[]
      pdfs: Prisma.$PdfPayload<ExtArgs>[]
      portion: Prisma.$portionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      portionId: number
      createdAt: Date
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type subjectGetPayload<S extends boolean | null | undefined | subjectDefaultArgs> = $Result.GetResult<Prisma.$subjectPayload, S>

  type subjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface subjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subject'], meta: { name: 'subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {subjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subjectFindUniqueArgs>(args: SelectSubset<T, subjectFindUniqueArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subjectFindUniqueOrThrowArgs>(args: SelectSubset<T, subjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subjectFindFirstArgs>(args?: SelectSubset<T, subjectFindFirstArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subjectFindFirstOrThrowArgs>(args?: SelectSubset<T, subjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends subjectFindManyArgs>(args?: SelectSubset<T, subjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Subject.
     * @param {subjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends subjectCreateArgs>(args: SelectSubset<T, subjectCreateArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Subjects.
     * @param {subjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subjectCreateManyArgs>(args?: SelectSubset<T, subjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subject.
     * @param {subjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends subjectDeleteArgs>(args: SelectSubset<T, subjectDeleteArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Subject.
     * @param {subjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subjectUpdateArgs>(args: SelectSubset<T, subjectUpdateArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Subjects.
     * @param {subjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subjectDeleteManyArgs>(args?: SelectSubset<T, subjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subjectUpdateManyArgs>(args: SelectSubset<T, subjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject.
     * @param {subjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends subjectUpsertArgs>(args: SelectSubset<T, subjectUpsertArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends subjectCountArgs>(
      args?: Subset<T, subjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subjectGroupByArgs['orderBy'] }
        : { orderBy?: subjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subject model
   */
  readonly fields: subjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapters<T extends subject$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, subject$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    questions<T extends subject$questionsArgs<ExtArgs> = {}>(args?: Subset<T, subject$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    pdfs<T extends subject$pdfsArgs<ExtArgs> = {}>(args?: Subset<T, subject$pdfsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdfPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    portion<T extends portionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, portionDefaultArgs<ExtArgs>>): Prisma__portionClient<$Result.GetResult<Prisma.$portionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subject model
   */ 
  interface subjectFieldRefs {
    readonly id: FieldRef<"subject", 'Int'>
    readonly name: FieldRef<"subject", 'String'>
    readonly portionId: FieldRef<"subject", 'Int'>
    readonly createdAt: FieldRef<"subject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * subject findUnique
   */
  export type subjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * Filter, which subject to fetch.
     */
    where: subjectWhereUniqueInput
  }

  /**
   * subject findUniqueOrThrow
   */
  export type subjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * Filter, which subject to fetch.
     */
    where: subjectWhereUniqueInput
  }

  /**
   * subject findFirst
   */
  export type subjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * Filter, which subject to fetch.
     */
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectOrderByWithRelationInput | subjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * subject findFirstOrThrow
   */
  export type subjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * Filter, which subject to fetch.
     */
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectOrderByWithRelationInput | subjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * subject findMany
   */
  export type subjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectOrderByWithRelationInput | subjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subjects.
     */
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * subject create
   */
  export type subjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * The data needed to create a subject.
     */
    data: XOR<subjectCreateInput, subjectUncheckedCreateInput>
  }

  /**
   * subject createMany
   */
  export type subjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subjects.
     */
    data: subjectCreateManyInput | subjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subject update
   */
  export type subjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * The data needed to update a subject.
     */
    data: XOR<subjectUpdateInput, subjectUncheckedUpdateInput>
    /**
     * Choose, which subject to update.
     */
    where: subjectWhereUniqueInput
  }

  /**
   * subject updateMany
   */
  export type subjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subjects.
     */
    data: XOR<subjectUpdateManyMutationInput, subjectUncheckedUpdateManyInput>
    /**
     * Filter which subjects to update
     */
    where?: subjectWhereInput
    /**
     * Limit how many subjects to update.
     */
    limit?: number
  }

  /**
   * subject upsert
   */
  export type subjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * The filter to search for the subject to update in case it exists.
     */
    where: subjectWhereUniqueInput
    /**
     * In case the subject found by the `where` argument doesn't exist, create a new subject with this data.
     */
    create: XOR<subjectCreateInput, subjectUncheckedCreateInput>
    /**
     * In case the subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subjectUpdateInput, subjectUncheckedUpdateInput>
  }

  /**
   * subject delete
   */
  export type subjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * Filter which subject to delete.
     */
    where: subjectWhereUniqueInput
  }

  /**
   * subject deleteMany
   */
  export type subjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subjects to delete
     */
    where?: subjectWhereInput
    /**
     * Limit how many subjects to delete.
     */
    limit?: number
  }

  /**
   * subject.chapters
   */
  export type subject$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    where?: chapterWhereInput
    orderBy?: chapterOrderByWithRelationInput | chapterOrderByWithRelationInput[]
    cursor?: chapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * subject.questions
   */
  export type subject$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    where?: questionWhereInput
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    cursor?: questionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * subject.pdfs
   */
  export type subject$pdfsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
    where?: PdfWhereInput
    orderBy?: PdfOrderByWithRelationInput | PdfOrderByWithRelationInput[]
    cursor?: PdfWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PdfScalarFieldEnum | PdfScalarFieldEnum[]
  }

  /**
   * subject without action
   */
  export type subjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
  }


  /**
   * Model chapter
   */

  export type AggregateChapter = {
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  export type ChapterAvgAggregateOutputType = {
    id: number | null
    subjectId: number | null
  }

  export type ChapterSumAggregateOutputType = {
    id: number | null
    subjectId: number | null
  }

  export type ChapterMinAggregateOutputType = {
    id: number | null
    name: string | null
    subjectId: number | null
    createdAt: Date | null
  }

  export type ChapterMaxAggregateOutputType = {
    id: number | null
    name: string | null
    subjectId: number | null
    createdAt: Date | null
  }

  export type ChapterCountAggregateOutputType = {
    id: number
    name: number
    subjectId: number
    createdAt: number
    _all: number
  }


  export type ChapterAvgAggregateInputType = {
    id?: true
    subjectId?: true
  }

  export type ChapterSumAggregateInputType = {
    id?: true
    subjectId?: true
  }

  export type ChapterMinAggregateInputType = {
    id?: true
    name?: true
    subjectId?: true
    createdAt?: true
  }

  export type ChapterMaxAggregateInputType = {
    id?: true
    name?: true
    subjectId?: true
    createdAt?: true
  }

  export type ChapterCountAggregateInputType = {
    id?: true
    name?: true
    subjectId?: true
    createdAt?: true
    _all?: true
  }

  export type ChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapter to aggregate.
     */
    where?: chapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapters to fetch.
     */
    orderBy?: chapterOrderByWithRelationInput | chapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chapters
    **/
    _count?: true | ChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterMaxAggregateInputType
  }

  export type GetChapterAggregateType<T extends ChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter[P]>
      : GetScalarType<T[P], AggregateChapter[P]>
  }




  export type chapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chapterWhereInput
    orderBy?: chapterOrderByWithAggregationInput | chapterOrderByWithAggregationInput[]
    by: ChapterScalarFieldEnum[] | ChapterScalarFieldEnum
    having?: chapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterCountAggregateInputType | true
    _avg?: ChapterAvgAggregateInputType
    _sum?: ChapterSumAggregateInputType
    _min?: ChapterMinAggregateInputType
    _max?: ChapterMaxAggregateInputType
  }

  export type ChapterGroupByOutputType = {
    id: number
    name: string
    subjectId: number
    createdAt: Date
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  type GetChapterGroupByPayload<T extends chapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterGroupByOutputType[P]>
        }
      >
    >


  export type chapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subjectId?: boolean
    createdAt?: boolean
    questions?: boolean | chapter$questionsArgs<ExtArgs>
    pdfs?: boolean | chapter$pdfsArgs<ExtArgs>
    subject?: boolean | subjectDefaultArgs<ExtArgs>
    topics?: boolean | chapter$topicsArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>



  export type chapterSelectScalar = {
    id?: boolean
    name?: boolean
    subjectId?: boolean
    createdAt?: boolean
  }

  export type chapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subjectId" | "createdAt", ExtArgs["result"]["chapter"]>
  export type chapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | chapter$questionsArgs<ExtArgs>
    pdfs?: boolean | chapter$pdfsArgs<ExtArgs>
    subject?: boolean | subjectDefaultArgs<ExtArgs>
    topics?: boolean | chapter$topicsArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $chapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chapter"
    objects: {
      questions: Prisma.$questionPayload<ExtArgs>[]
      pdfs: Prisma.$PdfPayload<ExtArgs>[]
      subject: Prisma.$subjectPayload<ExtArgs>
      topics: Prisma.$topicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      subjectId: number
      createdAt: Date
    }, ExtArgs["result"]["chapter"]>
    composites: {}
  }

  type chapterGetPayload<S extends boolean | null | undefined | chapterDefaultArgs> = $Result.GetResult<Prisma.$chapterPayload, S>

  type chapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterCountAggregateInputType | true
    }

  export interface chapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chapter'], meta: { name: 'chapter' } }
    /**
     * Find zero or one Chapter that matches the filter.
     * @param {chapterFindUniqueArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chapterFindUniqueArgs>(args: SelectSubset<T, chapterFindUniqueArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Chapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chapterFindUniqueOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chapterFindUniqueOrThrowArgs>(args: SelectSubset<T, chapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Chapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapterFindFirstArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chapterFindFirstArgs>(args?: SelectSubset<T, chapterFindFirstArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Chapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapterFindFirstOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chapterFindFirstOrThrowArgs>(args?: SelectSubset<T, chapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapter.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterWithIdOnly = await prisma.chapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chapterFindManyArgs>(args?: SelectSubset<T, chapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Chapter.
     * @param {chapterCreateArgs} args - Arguments to create a Chapter.
     * @example
     * // Create one Chapter
     * const Chapter = await prisma.chapter.create({
     *   data: {
     *     // ... data to create a Chapter
     *   }
     * })
     * 
     */
    create<T extends chapterCreateArgs>(args: SelectSubset<T, chapterCreateArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Chapters.
     * @param {chapterCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chapterCreateManyArgs>(args?: SelectSubset<T, chapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chapter.
     * @param {chapterDeleteArgs} args - Arguments to delete one Chapter.
     * @example
     * // Delete one Chapter
     * const Chapter = await prisma.chapter.delete({
     *   where: {
     *     // ... filter to delete one Chapter
     *   }
     * })
     * 
     */
    delete<T extends chapterDeleteArgs>(args: SelectSubset<T, chapterDeleteArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Chapter.
     * @param {chapterUpdateArgs} args - Arguments to update one Chapter.
     * @example
     * // Update one Chapter
     * const chapter = await prisma.chapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chapterUpdateArgs>(args: SelectSubset<T, chapterUpdateArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Chapters.
     * @param {chapterDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chapterDeleteManyArgs>(args?: SelectSubset<T, chapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chapterUpdateManyArgs>(args: SelectSubset<T, chapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chapter.
     * @param {chapterUpsertArgs} args - Arguments to update or create a Chapter.
     * @example
     * // Update or create a Chapter
     * const chapter = await prisma.chapter.upsert({
     *   create: {
     *     // ... data to create a Chapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter we want to update
     *   }
     * })
     */
    upsert<T extends chapterUpsertArgs>(args: SelectSubset<T, chapterUpsertArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapterCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapter.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends chapterCountArgs>(
      args?: Subset<T, chapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterAggregateArgs>(args: Subset<T, ChapterAggregateArgs>): Prisma.PrismaPromise<GetChapterAggregateType<T>>

    /**
     * Group by Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chapterGroupByArgs['orderBy'] }
        : { orderBy?: chapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chapter model
   */
  readonly fields: chapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends chapter$questionsArgs<ExtArgs> = {}>(args?: Subset<T, chapter$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    pdfs<T extends chapter$pdfsArgs<ExtArgs> = {}>(args?: Subset<T, chapter$pdfsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdfPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    subject<T extends subjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectDefaultArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    topics<T extends chapter$topicsArgs<ExtArgs> = {}>(args?: Subset<T, chapter$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$topicPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chapter model
   */ 
  interface chapterFieldRefs {
    readonly id: FieldRef<"chapter", 'Int'>
    readonly name: FieldRef<"chapter", 'String'>
    readonly subjectId: FieldRef<"chapter", 'Int'>
    readonly createdAt: FieldRef<"chapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chapter findUnique
   */
  export type chapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * Filter, which chapter to fetch.
     */
    where: chapterWhereUniqueInput
  }

  /**
   * chapter findUniqueOrThrow
   */
  export type chapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * Filter, which chapter to fetch.
     */
    where: chapterWhereUniqueInput
  }

  /**
   * chapter findFirst
   */
  export type chapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * Filter, which chapter to fetch.
     */
    where?: chapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapters to fetch.
     */
    orderBy?: chapterOrderByWithRelationInput | chapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapters.
     */
    cursor?: chapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * chapter findFirstOrThrow
   */
  export type chapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * Filter, which chapter to fetch.
     */
    where?: chapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapters to fetch.
     */
    orderBy?: chapterOrderByWithRelationInput | chapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapters.
     */
    cursor?: chapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * chapter findMany
   */
  export type chapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * Filter, which chapters to fetch.
     */
    where?: chapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapters to fetch.
     */
    orderBy?: chapterOrderByWithRelationInput | chapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chapters.
     */
    cursor?: chapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapters.
     */
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * chapter create
   */
  export type chapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * The data needed to create a chapter.
     */
    data: XOR<chapterCreateInput, chapterUncheckedCreateInput>
  }

  /**
   * chapter createMany
   */
  export type chapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chapters.
     */
    data: chapterCreateManyInput | chapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chapter update
   */
  export type chapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * The data needed to update a chapter.
     */
    data: XOR<chapterUpdateInput, chapterUncheckedUpdateInput>
    /**
     * Choose, which chapter to update.
     */
    where: chapterWhereUniqueInput
  }

  /**
   * chapter updateMany
   */
  export type chapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chapters.
     */
    data: XOR<chapterUpdateManyMutationInput, chapterUncheckedUpdateManyInput>
    /**
     * Filter which chapters to update
     */
    where?: chapterWhereInput
    /**
     * Limit how many chapters to update.
     */
    limit?: number
  }

  /**
   * chapter upsert
   */
  export type chapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * The filter to search for the chapter to update in case it exists.
     */
    where: chapterWhereUniqueInput
    /**
     * In case the chapter found by the `where` argument doesn't exist, create a new chapter with this data.
     */
    create: XOR<chapterCreateInput, chapterUncheckedCreateInput>
    /**
     * In case the chapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chapterUpdateInput, chapterUncheckedUpdateInput>
  }

  /**
   * chapter delete
   */
  export type chapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * Filter which chapter to delete.
     */
    where: chapterWhereUniqueInput
  }

  /**
   * chapter deleteMany
   */
  export type chapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapters to delete
     */
    where?: chapterWhereInput
    /**
     * Limit how many chapters to delete.
     */
    limit?: number
  }

  /**
   * chapter.questions
   */
  export type chapter$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    where?: questionWhereInput
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    cursor?: questionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * chapter.pdfs
   */
  export type chapter$pdfsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
    where?: PdfWhereInput
    orderBy?: PdfOrderByWithRelationInput | PdfOrderByWithRelationInput[]
    cursor?: PdfWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PdfScalarFieldEnum | PdfScalarFieldEnum[]
  }

  /**
   * chapter.topics
   */
  export type chapter$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topic
     */
    select?: topicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the topic
     */
    omit?: topicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicInclude<ExtArgs> | null
    where?: topicWhereInput
    orderBy?: topicOrderByWithRelationInput | topicOrderByWithRelationInput[]
    cursor?: topicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * chapter without action
   */
  export type chapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
  }


  /**
   * Model topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicAvgAggregateOutputType = {
    id: number | null
    chapterId: number | null
  }

  export type TopicSumAggregateOutputType = {
    id: number | null
    chapterId: number | null
  }

  export type TopicMinAggregateOutputType = {
    id: number | null
    name: string | null
    chapterId: number | null
    createdAt: Date | null
  }

  export type TopicMaxAggregateOutputType = {
    id: number | null
    name: string | null
    chapterId: number | null
    createdAt: Date | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    name: number
    chapterId: number
    createdAt: number
    _all: number
  }


  export type TopicAvgAggregateInputType = {
    id?: true
    chapterId?: true
  }

  export type TopicSumAggregateInputType = {
    id?: true
    chapterId?: true
  }

  export type TopicMinAggregateInputType = {
    id?: true
    name?: true
    chapterId?: true
    createdAt?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    name?: true
    chapterId?: true
    createdAt?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    name?: true
    chapterId?: true
    createdAt?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which topic to aggregate.
     */
    where?: topicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     */
    orderBy?: topicOrderByWithRelationInput | topicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: topicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type topicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: topicWhereInput
    orderBy?: topicOrderByWithAggregationInput | topicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: topicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _avg?: TopicAvgAggregateInputType
    _sum?: TopicSumAggregateInputType
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    id: number
    name: string
    chapterId: number
    createdAt: Date
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends topicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type topicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    chapterId?: boolean
    createdAt?: boolean
    questions?: boolean | topic$questionsArgs<ExtArgs>
    pdfs?: boolean | topic$pdfsArgs<ExtArgs>
    chapter?: boolean | chapterDefaultArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>



  export type topicSelectScalar = {
    id?: boolean
    name?: boolean
    chapterId?: boolean
    createdAt?: boolean
  }

  export type topicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "chapterId" | "createdAt", ExtArgs["result"]["topic"]>
  export type topicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | topic$questionsArgs<ExtArgs>
    pdfs?: boolean | topic$pdfsArgs<ExtArgs>
    chapter?: boolean | chapterDefaultArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $topicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "topic"
    objects: {
      questions: Prisma.$questionPayload<ExtArgs>[]
      pdfs: Prisma.$PdfPayload<ExtArgs>[]
      chapter: Prisma.$chapterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      chapterId: number
      createdAt: Date
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type topicGetPayload<S extends boolean | null | undefined | topicDefaultArgs> = $Result.GetResult<Prisma.$topicPayload, S>

  type topicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<topicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface topicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['topic'], meta: { name: 'topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {topicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends topicFindUniqueArgs>(args: SelectSubset<T, topicFindUniqueArgs<ExtArgs>>): Prisma__topicClient<$Result.GetResult<Prisma.$topicPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {topicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends topicFindUniqueOrThrowArgs>(args: SelectSubset<T, topicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__topicClient<$Result.GetResult<Prisma.$topicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends topicFindFirstArgs>(args?: SelectSubset<T, topicFindFirstArgs<ExtArgs>>): Prisma__topicClient<$Result.GetResult<Prisma.$topicPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends topicFindFirstOrThrowArgs>(args?: SelectSubset<T, topicFindFirstOrThrowArgs<ExtArgs>>): Prisma__topicClient<$Result.GetResult<Prisma.$topicPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends topicFindManyArgs>(args?: SelectSubset<T, topicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$topicPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Topic.
     * @param {topicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends topicCreateArgs>(args: SelectSubset<T, topicCreateArgs<ExtArgs>>): Prisma__topicClient<$Result.GetResult<Prisma.$topicPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Topics.
     * @param {topicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends topicCreateManyArgs>(args?: SelectSubset<T, topicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Topic.
     * @param {topicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends topicDeleteArgs>(args: SelectSubset<T, topicDeleteArgs<ExtArgs>>): Prisma__topicClient<$Result.GetResult<Prisma.$topicPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Topic.
     * @param {topicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends topicUpdateArgs>(args: SelectSubset<T, topicUpdateArgs<ExtArgs>>): Prisma__topicClient<$Result.GetResult<Prisma.$topicPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Topics.
     * @param {topicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends topicDeleteManyArgs>(args?: SelectSubset<T, topicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends topicUpdateManyArgs>(args: SelectSubset<T, topicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Topic.
     * @param {topicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends topicUpsertArgs>(args: SelectSubset<T, topicUpsertArgs<ExtArgs>>): Prisma__topicClient<$Result.GetResult<Prisma.$topicPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends topicCountArgs>(
      args?: Subset<T, topicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends topicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: topicGroupByArgs['orderBy'] }
        : { orderBy?: topicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, topicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the topic model
   */
  readonly fields: topicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__topicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends topic$questionsArgs<ExtArgs> = {}>(args?: Subset<T, topic$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    pdfs<T extends topic$pdfsArgs<ExtArgs> = {}>(args?: Subset<T, topic$pdfsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdfPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    chapter<T extends chapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, chapterDefaultArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the topic model
   */ 
  interface topicFieldRefs {
    readonly id: FieldRef<"topic", 'Int'>
    readonly name: FieldRef<"topic", 'String'>
    readonly chapterId: FieldRef<"topic", 'Int'>
    readonly createdAt: FieldRef<"topic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * topic findUnique
   */
  export type topicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topic
     */
    select?: topicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the topic
     */
    omit?: topicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicInclude<ExtArgs> | null
    /**
     * Filter, which topic to fetch.
     */
    where: topicWhereUniqueInput
  }

  /**
   * topic findUniqueOrThrow
   */
  export type topicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topic
     */
    select?: topicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the topic
     */
    omit?: topicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicInclude<ExtArgs> | null
    /**
     * Filter, which topic to fetch.
     */
    where: topicWhereUniqueInput
  }

  /**
   * topic findFirst
   */
  export type topicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topic
     */
    select?: topicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the topic
     */
    omit?: topicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicInclude<ExtArgs> | null
    /**
     * Filter, which topic to fetch.
     */
    where?: topicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     */
    orderBy?: topicOrderByWithRelationInput | topicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for topics.
     */
    cursor?: topicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * topic findFirstOrThrow
   */
  export type topicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topic
     */
    select?: topicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the topic
     */
    omit?: topicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicInclude<ExtArgs> | null
    /**
     * Filter, which topic to fetch.
     */
    where?: topicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     */
    orderBy?: topicOrderByWithRelationInput | topicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for topics.
     */
    cursor?: topicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * topic findMany
   */
  export type topicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topic
     */
    select?: topicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the topic
     */
    omit?: topicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicInclude<ExtArgs> | null
    /**
     * Filter, which topics to fetch.
     */
    where?: topicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     */
    orderBy?: topicOrderByWithRelationInput | topicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing topics.
     */
    cursor?: topicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * topic create
   */
  export type topicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topic
     */
    select?: topicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the topic
     */
    omit?: topicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicInclude<ExtArgs> | null
    /**
     * The data needed to create a topic.
     */
    data: XOR<topicCreateInput, topicUncheckedCreateInput>
  }

  /**
   * topic createMany
   */
  export type topicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many topics.
     */
    data: topicCreateManyInput | topicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * topic update
   */
  export type topicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topic
     */
    select?: topicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the topic
     */
    omit?: topicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicInclude<ExtArgs> | null
    /**
     * The data needed to update a topic.
     */
    data: XOR<topicUpdateInput, topicUncheckedUpdateInput>
    /**
     * Choose, which topic to update.
     */
    where: topicWhereUniqueInput
  }

  /**
   * topic updateMany
   */
  export type topicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update topics.
     */
    data: XOR<topicUpdateManyMutationInput, topicUncheckedUpdateManyInput>
    /**
     * Filter which topics to update
     */
    where?: topicWhereInput
    /**
     * Limit how many topics to update.
     */
    limit?: number
  }

  /**
   * topic upsert
   */
  export type topicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topic
     */
    select?: topicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the topic
     */
    omit?: topicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicInclude<ExtArgs> | null
    /**
     * The filter to search for the topic to update in case it exists.
     */
    where: topicWhereUniqueInput
    /**
     * In case the topic found by the `where` argument doesn't exist, create a new topic with this data.
     */
    create: XOR<topicCreateInput, topicUncheckedCreateInput>
    /**
     * In case the topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<topicUpdateInput, topicUncheckedUpdateInput>
  }

  /**
   * topic delete
   */
  export type topicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topic
     */
    select?: topicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the topic
     */
    omit?: topicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicInclude<ExtArgs> | null
    /**
     * Filter which topic to delete.
     */
    where: topicWhereUniqueInput
  }

  /**
   * topic deleteMany
   */
  export type topicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which topics to delete
     */
    where?: topicWhereInput
    /**
     * Limit how many topics to delete.
     */
    limit?: number
  }

  /**
   * topic.questions
   */
  export type topic$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    where?: questionWhereInput
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    cursor?: questionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * topic.pdfs
   */
  export type topic$pdfsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
    where?: PdfWhereInput
    orderBy?: PdfOrderByWithRelationInput | PdfOrderByWithRelationInput[]
    cursor?: PdfWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PdfScalarFieldEnum | PdfScalarFieldEnum[]
  }

  /**
   * topic without action
   */
  export type topicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topic
     */
    select?: topicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the topic
     */
    omit?: topicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicInclude<ExtArgs> | null
  }


  /**
   * Model question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    id: number | null
    questionTypeId: number | null
    portionId: number | null
    subjectId: number | null
    chapterId: number | null
    topicId: number | null
  }

  export type QuestionSumAggregateOutputType = {
    id: number | null
    questionTypeId: number | null
    portionId: number | null
    subjectId: number | null
    chapterId: number | null
    topicId: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: number | null
    questionTypeId: number | null
    portionId: number | null
    subjectId: number | null
    chapterId: number | null
    topicId: number | null
    question: string | null
    image: string | null
    optionA: string | null
    optionB: string | null
    optionC: string | null
    optionD: string | null
    correctOption: string | null
    hint: string | null
    hintImage: string | null
    createdAt: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: number | null
    questionTypeId: number | null
    portionId: number | null
    subjectId: number | null
    chapterId: number | null
    topicId: number | null
    question: string | null
    image: string | null
    optionA: string | null
    optionB: string | null
    optionC: string | null
    optionD: string | null
    correctOption: string | null
    hint: string | null
    hintImage: string | null
    createdAt: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    questionTypeId: number
    portionId: number
    subjectId: number
    chapterId: number
    topicId: number
    question: number
    image: number
    optionA: number
    optionB: number
    optionC: number
    optionD: number
    correctOption: number
    hint: number
    hintImage: number
    createdAt: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    id?: true
    questionTypeId?: true
    portionId?: true
    subjectId?: true
    chapterId?: true
    topicId?: true
  }

  export type QuestionSumAggregateInputType = {
    id?: true
    questionTypeId?: true
    portionId?: true
    subjectId?: true
    chapterId?: true
    topicId?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    questionTypeId?: true
    portionId?: true
    subjectId?: true
    chapterId?: true
    topicId?: true
    question?: true
    image?: true
    optionA?: true
    optionB?: true
    optionC?: true
    optionD?: true
    correctOption?: true
    hint?: true
    hintImage?: true
    createdAt?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    questionTypeId?: true
    portionId?: true
    subjectId?: true
    chapterId?: true
    topicId?: true
    question?: true
    image?: true
    optionA?: true
    optionB?: true
    optionC?: true
    optionD?: true
    correctOption?: true
    hint?: true
    hintImage?: true
    createdAt?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    questionTypeId?: true
    portionId?: true
    subjectId?: true
    chapterId?: true
    topicId?: true
    question?: true
    image?: true
    optionA?: true
    optionB?: true
    optionC?: true
    optionD?: true
    correctOption?: true
    hint?: true
    hintImage?: true
    createdAt?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which question to aggregate.
     */
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type questionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionWhereInput
    orderBy?: questionOrderByWithAggregationInput | questionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: questionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: number
    questionTypeId: number
    portionId: number
    subjectId: number
    chapterId: number
    topicId: number
    question: string
    image: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint: string | null
    hintImage: string | null
    createdAt: Date
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends questionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type questionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionTypeId?: boolean
    portionId?: boolean
    subjectId?: boolean
    chapterId?: boolean
    topicId?: boolean
    question?: boolean
    image?: boolean
    optionA?: boolean
    optionB?: boolean
    optionC?: boolean
    optionD?: boolean
    correctOption?: boolean
    hint?: boolean
    hintImage?: boolean
    createdAt?: boolean
    questionType?: boolean | questionTypeDefaultArgs<ExtArgs>
    portion?: boolean | portionDefaultArgs<ExtArgs>
    subject?: boolean | subjectDefaultArgs<ExtArgs>
    chapter?: boolean | chapterDefaultArgs<ExtArgs>
    topic?: boolean | topicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>



  export type questionSelectScalar = {
    id?: boolean
    questionTypeId?: boolean
    portionId?: boolean
    subjectId?: boolean
    chapterId?: boolean
    topicId?: boolean
    question?: boolean
    image?: boolean
    optionA?: boolean
    optionB?: boolean
    optionC?: boolean
    optionD?: boolean
    correctOption?: boolean
    hint?: boolean
    hintImage?: boolean
    createdAt?: boolean
  }

  export type questionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionTypeId" | "portionId" | "subjectId" | "chapterId" | "topicId" | "question" | "image" | "optionA" | "optionB" | "optionC" | "optionD" | "correctOption" | "hint" | "hintImage" | "createdAt", ExtArgs["result"]["question"]>
  export type questionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questionType?: boolean | questionTypeDefaultArgs<ExtArgs>
    portion?: boolean | portionDefaultArgs<ExtArgs>
    subject?: boolean | subjectDefaultArgs<ExtArgs>
    chapter?: boolean | chapterDefaultArgs<ExtArgs>
    topic?: boolean | topicDefaultArgs<ExtArgs>
  }

  export type $questionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "question"
    objects: {
      questionType: Prisma.$questionTypePayload<ExtArgs>
      portion: Prisma.$portionPayload<ExtArgs>
      subject: Prisma.$subjectPayload<ExtArgs>
      chapter: Prisma.$chapterPayload<ExtArgs>
      topic: Prisma.$topicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      questionTypeId: number
      portionId: number
      subjectId: number
      chapterId: number
      topicId: number
      question: string
      image: string | null
      optionA: string
      optionB: string
      optionC: string
      optionD: string
      correctOption: string
      hint: string | null
      hintImage: string | null
      createdAt: Date
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type questionGetPayload<S extends boolean | null | undefined | questionDefaultArgs> = $Result.GetResult<Prisma.$questionPayload, S>

  type questionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<questionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface questionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['question'], meta: { name: 'question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {questionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questionFindUniqueArgs>(args: SelectSubset<T, questionFindUniqueArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {questionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questionFindUniqueOrThrowArgs>(args: SelectSubset<T, questionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questionFindFirstArgs>(args?: SelectSubset<T, questionFindFirstArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questionFindFirstOrThrowArgs>(args?: SelectSubset<T, questionFindFirstOrThrowArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questionFindManyArgs>(args?: SelectSubset<T, questionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Question.
     * @param {questionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends questionCreateArgs>(args: SelectSubset<T, questionCreateArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Questions.
     * @param {questionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questionCreateManyArgs>(args?: SelectSubset<T, questionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Question.
     * @param {questionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends questionDeleteArgs>(args: SelectSubset<T, questionDeleteArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Question.
     * @param {questionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questionUpdateArgs>(args: SelectSubset<T, questionUpdateArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Questions.
     * @param {questionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questionDeleteManyArgs>(args?: SelectSubset<T, questionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questionUpdateManyArgs>(args: SelectSubset<T, questionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {questionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends questionUpsertArgs>(args: SelectSubset<T, questionUpsertArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends questionCountArgs>(
      args?: Subset<T, questionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionGroupByArgs['orderBy'] }
        : { orderBy?: questionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the question model
   */
  readonly fields: questionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questionType<T extends questionTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, questionTypeDefaultArgs<ExtArgs>>): Prisma__questionTypeClient<$Result.GetResult<Prisma.$questionTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    portion<T extends portionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, portionDefaultArgs<ExtArgs>>): Prisma__portionClient<$Result.GetResult<Prisma.$portionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    subject<T extends subjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectDefaultArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    chapter<T extends chapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, chapterDefaultArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    topic<T extends topicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, topicDefaultArgs<ExtArgs>>): Prisma__topicClient<$Result.GetResult<Prisma.$topicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the question model
   */ 
  interface questionFieldRefs {
    readonly id: FieldRef<"question", 'Int'>
    readonly questionTypeId: FieldRef<"question", 'Int'>
    readonly portionId: FieldRef<"question", 'Int'>
    readonly subjectId: FieldRef<"question", 'Int'>
    readonly chapterId: FieldRef<"question", 'Int'>
    readonly topicId: FieldRef<"question", 'Int'>
    readonly question: FieldRef<"question", 'String'>
    readonly image: FieldRef<"question", 'String'>
    readonly optionA: FieldRef<"question", 'String'>
    readonly optionB: FieldRef<"question", 'String'>
    readonly optionC: FieldRef<"question", 'String'>
    readonly optionD: FieldRef<"question", 'String'>
    readonly correctOption: FieldRef<"question", 'String'>
    readonly hint: FieldRef<"question", 'String'>
    readonly hintImage: FieldRef<"question", 'String'>
    readonly createdAt: FieldRef<"question", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * question findUnique
   */
  export type questionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which question to fetch.
     */
    where: questionWhereUniqueInput
  }

  /**
   * question findUniqueOrThrow
   */
  export type questionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which question to fetch.
     */
    where: questionWhereUniqueInput
  }

  /**
   * question findFirst
   */
  export type questionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which question to fetch.
     */
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * question findFirstOrThrow
   */
  export type questionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which question to fetch.
     */
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * question findMany
   */
  export type questionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions.
     */
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * question create
   */
  export type questionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * The data needed to create a question.
     */
    data: XOR<questionCreateInput, questionUncheckedCreateInput>
  }

  /**
   * question createMany
   */
  export type questionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questions.
     */
    data: questionCreateManyInput | questionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * question update
   */
  export type questionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * The data needed to update a question.
     */
    data: XOR<questionUpdateInput, questionUncheckedUpdateInput>
    /**
     * Choose, which question to update.
     */
    where: questionWhereUniqueInput
  }

  /**
   * question updateMany
   */
  export type questionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questions.
     */
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     */
    where?: questionWhereInput
    /**
     * Limit how many questions to update.
     */
    limit?: number
  }

  /**
   * question upsert
   */
  export type questionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * The filter to search for the question to update in case it exists.
     */
    where: questionWhereUniqueInput
    /**
     * In case the question found by the `where` argument doesn't exist, create a new question with this data.
     */
    create: XOR<questionCreateInput, questionUncheckedCreateInput>
    /**
     * In case the question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionUpdateInput, questionUncheckedUpdateInput>
  }

  /**
   * question delete
   */
  export type questionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter which question to delete.
     */
    where: questionWhereUniqueInput
  }

  /**
   * question deleteMany
   */
  export type questionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to delete
     */
    where?: questionWhereInput
    /**
     * Limit how many questions to delete.
     */
    limit?: number
  }

  /**
   * question without action
   */
  export type questionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
  }


  /**
   * Model Pdf
   */

  export type AggregatePdf = {
    _count: PdfCountAggregateOutputType | null
    _avg: PdfAvgAggregateOutputType | null
    _sum: PdfSumAggregateOutputType | null
    _min: PdfMinAggregateOutputType | null
    _max: PdfMaxAggregateOutputType | null
  }

  export type PdfAvgAggregateOutputType = {
    id: number | null
    portionId: number | null
    subjectId: number | null
    chapterId: number | null
    topicId: number | null
  }

  export type PdfSumAggregateOutputType = {
    id: number | null
    portionId: number | null
    subjectId: number | null
    chapterId: number | null
    topicId: number | null
  }

  export type PdfMinAggregateOutputType = {
    id: number | null
    name: string | null
    url: string | null
    portionId: number | null
    subjectId: number | null
    chapterId: number | null
    topicId: number | null
    createdAt: Date | null
  }

  export type PdfMaxAggregateOutputType = {
    id: number | null
    name: string | null
    url: string | null
    portionId: number | null
    subjectId: number | null
    chapterId: number | null
    topicId: number | null
    createdAt: Date | null
  }

  export type PdfCountAggregateOutputType = {
    id: number
    name: number
    url: number
    portionId: number
    subjectId: number
    chapterId: number
    topicId: number
    createdAt: number
    _all: number
  }


  export type PdfAvgAggregateInputType = {
    id?: true
    portionId?: true
    subjectId?: true
    chapterId?: true
    topicId?: true
  }

  export type PdfSumAggregateInputType = {
    id?: true
    portionId?: true
    subjectId?: true
    chapterId?: true
    topicId?: true
  }

  export type PdfMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    portionId?: true
    subjectId?: true
    chapterId?: true
    topicId?: true
    createdAt?: true
  }

  export type PdfMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    portionId?: true
    subjectId?: true
    chapterId?: true
    topicId?: true
    createdAt?: true
  }

  export type PdfCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    portionId?: true
    subjectId?: true
    chapterId?: true
    topicId?: true
    createdAt?: true
    _all?: true
  }

  export type PdfAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pdf to aggregate.
     */
    where?: PdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pdfs to fetch.
     */
    orderBy?: PdfOrderByWithRelationInput | PdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pdfs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pdfs
    **/
    _count?: true | PdfCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PdfAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PdfSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PdfMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PdfMaxAggregateInputType
  }

  export type GetPdfAggregateType<T extends PdfAggregateArgs> = {
        [P in keyof T & keyof AggregatePdf]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePdf[P]>
      : GetScalarType<T[P], AggregatePdf[P]>
  }




  export type PdfGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PdfWhereInput
    orderBy?: PdfOrderByWithAggregationInput | PdfOrderByWithAggregationInput[]
    by: PdfScalarFieldEnum[] | PdfScalarFieldEnum
    having?: PdfScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PdfCountAggregateInputType | true
    _avg?: PdfAvgAggregateInputType
    _sum?: PdfSumAggregateInputType
    _min?: PdfMinAggregateInputType
    _max?: PdfMaxAggregateInputType
  }

  export type PdfGroupByOutputType = {
    id: number
    name: string
    url: string
    portionId: number | null
    subjectId: number | null
    chapterId: number | null
    topicId: number | null
    createdAt: Date
    _count: PdfCountAggregateOutputType | null
    _avg: PdfAvgAggregateOutputType | null
    _sum: PdfSumAggregateOutputType | null
    _min: PdfMinAggregateOutputType | null
    _max: PdfMaxAggregateOutputType | null
  }

  type GetPdfGroupByPayload<T extends PdfGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PdfGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PdfGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PdfGroupByOutputType[P]>
            : GetScalarType<T[P], PdfGroupByOutputType[P]>
        }
      >
    >


  export type PdfSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    portionId?: boolean
    subjectId?: boolean
    chapterId?: boolean
    topicId?: boolean
    createdAt?: boolean
    portion?: boolean | Pdf$portionArgs<ExtArgs>
    subject?: boolean | Pdf$subjectArgs<ExtArgs>
    chapter?: boolean | Pdf$chapterArgs<ExtArgs>
    topic?: boolean | Pdf$topicArgs<ExtArgs>
  }, ExtArgs["result"]["pdf"]>



  export type PdfSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    portionId?: boolean
    subjectId?: boolean
    chapterId?: boolean
    topicId?: boolean
    createdAt?: boolean
  }

  export type PdfOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "url" | "portionId" | "subjectId" | "chapterId" | "topicId" | "createdAt", ExtArgs["result"]["pdf"]>
  export type PdfInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portion?: boolean | Pdf$portionArgs<ExtArgs>
    subject?: boolean | Pdf$subjectArgs<ExtArgs>
    chapter?: boolean | Pdf$chapterArgs<ExtArgs>
    topic?: boolean | Pdf$topicArgs<ExtArgs>
  }

  export type $PdfPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pdf"
    objects: {
      portion: Prisma.$portionPayload<ExtArgs> | null
      subject: Prisma.$subjectPayload<ExtArgs> | null
      chapter: Prisma.$chapterPayload<ExtArgs> | null
      topic: Prisma.$topicPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      url: string
      portionId: number | null
      subjectId: number | null
      chapterId: number | null
      topicId: number | null
      createdAt: Date
    }, ExtArgs["result"]["pdf"]>
    composites: {}
  }

  type PdfGetPayload<S extends boolean | null | undefined | PdfDefaultArgs> = $Result.GetResult<Prisma.$PdfPayload, S>

  type PdfCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PdfFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PdfCountAggregateInputType | true
    }

  export interface PdfDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pdf'], meta: { name: 'Pdf' } }
    /**
     * Find zero or one Pdf that matches the filter.
     * @param {PdfFindUniqueArgs} args - Arguments to find a Pdf
     * @example
     * // Get one Pdf
     * const pdf = await prisma.pdf.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PdfFindUniqueArgs>(args: SelectSubset<T, PdfFindUniqueArgs<ExtArgs>>): Prisma__PdfClient<$Result.GetResult<Prisma.$PdfPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Pdf that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PdfFindUniqueOrThrowArgs} args - Arguments to find a Pdf
     * @example
     * // Get one Pdf
     * const pdf = await prisma.pdf.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PdfFindUniqueOrThrowArgs>(args: SelectSubset<T, PdfFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PdfClient<$Result.GetResult<Prisma.$PdfPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Pdf that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfFindFirstArgs} args - Arguments to find a Pdf
     * @example
     * // Get one Pdf
     * const pdf = await prisma.pdf.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PdfFindFirstArgs>(args?: SelectSubset<T, PdfFindFirstArgs<ExtArgs>>): Prisma__PdfClient<$Result.GetResult<Prisma.$PdfPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Pdf that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfFindFirstOrThrowArgs} args - Arguments to find a Pdf
     * @example
     * // Get one Pdf
     * const pdf = await prisma.pdf.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PdfFindFirstOrThrowArgs>(args?: SelectSubset<T, PdfFindFirstOrThrowArgs<ExtArgs>>): Prisma__PdfClient<$Result.GetResult<Prisma.$PdfPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Pdfs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pdfs
     * const pdfs = await prisma.pdf.findMany()
     * 
     * // Get first 10 Pdfs
     * const pdfs = await prisma.pdf.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pdfWithIdOnly = await prisma.pdf.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PdfFindManyArgs>(args?: SelectSubset<T, PdfFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdfPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Pdf.
     * @param {PdfCreateArgs} args - Arguments to create a Pdf.
     * @example
     * // Create one Pdf
     * const Pdf = await prisma.pdf.create({
     *   data: {
     *     // ... data to create a Pdf
     *   }
     * })
     * 
     */
    create<T extends PdfCreateArgs>(args: SelectSubset<T, PdfCreateArgs<ExtArgs>>): Prisma__PdfClient<$Result.GetResult<Prisma.$PdfPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Pdfs.
     * @param {PdfCreateManyArgs} args - Arguments to create many Pdfs.
     * @example
     * // Create many Pdfs
     * const pdf = await prisma.pdf.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PdfCreateManyArgs>(args?: SelectSubset<T, PdfCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pdf.
     * @param {PdfDeleteArgs} args - Arguments to delete one Pdf.
     * @example
     * // Delete one Pdf
     * const Pdf = await prisma.pdf.delete({
     *   where: {
     *     // ... filter to delete one Pdf
     *   }
     * })
     * 
     */
    delete<T extends PdfDeleteArgs>(args: SelectSubset<T, PdfDeleteArgs<ExtArgs>>): Prisma__PdfClient<$Result.GetResult<Prisma.$PdfPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Pdf.
     * @param {PdfUpdateArgs} args - Arguments to update one Pdf.
     * @example
     * // Update one Pdf
     * const pdf = await prisma.pdf.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PdfUpdateArgs>(args: SelectSubset<T, PdfUpdateArgs<ExtArgs>>): Prisma__PdfClient<$Result.GetResult<Prisma.$PdfPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Pdfs.
     * @param {PdfDeleteManyArgs} args - Arguments to filter Pdfs to delete.
     * @example
     * // Delete a few Pdfs
     * const { count } = await prisma.pdf.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PdfDeleteManyArgs>(args?: SelectSubset<T, PdfDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pdfs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pdfs
     * const pdf = await prisma.pdf.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PdfUpdateManyArgs>(args: SelectSubset<T, PdfUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pdf.
     * @param {PdfUpsertArgs} args - Arguments to update or create a Pdf.
     * @example
     * // Update or create a Pdf
     * const pdf = await prisma.pdf.upsert({
     *   create: {
     *     // ... data to create a Pdf
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pdf we want to update
     *   }
     * })
     */
    upsert<T extends PdfUpsertArgs>(args: SelectSubset<T, PdfUpsertArgs<ExtArgs>>): Prisma__PdfClient<$Result.GetResult<Prisma.$PdfPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Pdfs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfCountArgs} args - Arguments to filter Pdfs to count.
     * @example
     * // Count the number of Pdfs
     * const count = await prisma.pdf.count({
     *   where: {
     *     // ... the filter for the Pdfs we want to count
     *   }
     * })
    **/
    count<T extends PdfCountArgs>(
      args?: Subset<T, PdfCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PdfCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pdf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PdfAggregateArgs>(args: Subset<T, PdfAggregateArgs>): Prisma.PrismaPromise<GetPdfAggregateType<T>>

    /**
     * Group by Pdf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PdfGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PdfGroupByArgs['orderBy'] }
        : { orderBy?: PdfGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PdfGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPdfGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pdf model
   */
  readonly fields: PdfFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pdf.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PdfClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portion<T extends Pdf$portionArgs<ExtArgs> = {}>(args?: Subset<T, Pdf$portionArgs<ExtArgs>>): Prisma__portionClient<$Result.GetResult<Prisma.$portionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    subject<T extends Pdf$subjectArgs<ExtArgs> = {}>(args?: Subset<T, Pdf$subjectArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    chapter<T extends Pdf$chapterArgs<ExtArgs> = {}>(args?: Subset<T, Pdf$chapterArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    topic<T extends Pdf$topicArgs<ExtArgs> = {}>(args?: Subset<T, Pdf$topicArgs<ExtArgs>>): Prisma__topicClient<$Result.GetResult<Prisma.$topicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pdf model
   */ 
  interface PdfFieldRefs {
    readonly id: FieldRef<"Pdf", 'Int'>
    readonly name: FieldRef<"Pdf", 'String'>
    readonly url: FieldRef<"Pdf", 'String'>
    readonly portionId: FieldRef<"Pdf", 'Int'>
    readonly subjectId: FieldRef<"Pdf", 'Int'>
    readonly chapterId: FieldRef<"Pdf", 'Int'>
    readonly topicId: FieldRef<"Pdf", 'Int'>
    readonly createdAt: FieldRef<"Pdf", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pdf findUnique
   */
  export type PdfFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
    /**
     * Filter, which Pdf to fetch.
     */
    where: PdfWhereUniqueInput
  }

  /**
   * Pdf findUniqueOrThrow
   */
  export type PdfFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
    /**
     * Filter, which Pdf to fetch.
     */
    where: PdfWhereUniqueInput
  }

  /**
   * Pdf findFirst
   */
  export type PdfFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
    /**
     * Filter, which Pdf to fetch.
     */
    where?: PdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pdfs to fetch.
     */
    orderBy?: PdfOrderByWithRelationInput | PdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pdfs.
     */
    cursor?: PdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pdfs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pdfs.
     */
    distinct?: PdfScalarFieldEnum | PdfScalarFieldEnum[]
  }

  /**
   * Pdf findFirstOrThrow
   */
  export type PdfFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
    /**
     * Filter, which Pdf to fetch.
     */
    where?: PdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pdfs to fetch.
     */
    orderBy?: PdfOrderByWithRelationInput | PdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pdfs.
     */
    cursor?: PdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pdfs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pdfs.
     */
    distinct?: PdfScalarFieldEnum | PdfScalarFieldEnum[]
  }

  /**
   * Pdf findMany
   */
  export type PdfFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
    /**
     * Filter, which Pdfs to fetch.
     */
    where?: PdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pdfs to fetch.
     */
    orderBy?: PdfOrderByWithRelationInput | PdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pdfs.
     */
    cursor?: PdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pdfs.
     */
    skip?: number
    distinct?: PdfScalarFieldEnum | PdfScalarFieldEnum[]
  }

  /**
   * Pdf create
   */
  export type PdfCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
    /**
     * The data needed to create a Pdf.
     */
    data: XOR<PdfCreateInput, PdfUncheckedCreateInput>
  }

  /**
   * Pdf createMany
   */
  export type PdfCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pdfs.
     */
    data: PdfCreateManyInput | PdfCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pdf update
   */
  export type PdfUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
    /**
     * The data needed to update a Pdf.
     */
    data: XOR<PdfUpdateInput, PdfUncheckedUpdateInput>
    /**
     * Choose, which Pdf to update.
     */
    where: PdfWhereUniqueInput
  }

  /**
   * Pdf updateMany
   */
  export type PdfUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pdfs.
     */
    data: XOR<PdfUpdateManyMutationInput, PdfUncheckedUpdateManyInput>
    /**
     * Filter which Pdfs to update
     */
    where?: PdfWhereInput
    /**
     * Limit how many Pdfs to update.
     */
    limit?: number
  }

  /**
   * Pdf upsert
   */
  export type PdfUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
    /**
     * The filter to search for the Pdf to update in case it exists.
     */
    where: PdfWhereUniqueInput
    /**
     * In case the Pdf found by the `where` argument doesn't exist, create a new Pdf with this data.
     */
    create: XOR<PdfCreateInput, PdfUncheckedCreateInput>
    /**
     * In case the Pdf was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PdfUpdateInput, PdfUncheckedUpdateInput>
  }

  /**
   * Pdf delete
   */
  export type PdfDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
    /**
     * Filter which Pdf to delete.
     */
    where: PdfWhereUniqueInput
  }

  /**
   * Pdf deleteMany
   */
  export type PdfDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pdfs to delete
     */
    where?: PdfWhereInput
    /**
     * Limit how many Pdfs to delete.
     */
    limit?: number
  }

  /**
   * Pdf.portion
   */
  export type Pdf$portionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portion
     */
    select?: portionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portion
     */
    omit?: portionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portionInclude<ExtArgs> | null
    where?: portionWhereInput
  }

  /**
   * Pdf.subject
   */
  export type Pdf$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    where?: subjectWhereInput
  }

  /**
   * Pdf.chapter
   */
  export type Pdf$chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    where?: chapterWhereInput
  }

  /**
   * Pdf.topic
   */
  export type Pdf$topicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topic
     */
    select?: topicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the topic
     */
    omit?: topicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicInclude<ExtArgs> | null
    where?: topicWhereInput
  }

  /**
   * Pdf without action
   */
  export type PdfDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pdf
     */
    select?: PdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pdf
     */
    omit?: PdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfInclude<ExtArgs> | null
  }


  /**
   * Model TestResult
   */

  export type AggregateTestResult = {
    _count: TestResultCountAggregateOutputType | null
    _avg: TestResultAvgAggregateOutputType | null
    _sum: TestResultSumAggregateOutputType | null
    _min: TestResultMinAggregateOutputType | null
    _max: TestResultMaxAggregateOutputType | null
  }

  export type TestResultAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    score: number | null
    totalMarks: number | null
    answered: number | null
    correct: number | null
    wrong: number | null
    unanswered: number | null
    accuracy: number | null
    totalTimeTaken: number | null
  }

  export type TestResultSumAggregateOutputType = {
    id: number | null
    userId: number | null
    score: number | null
    totalMarks: number | null
    answered: number | null
    correct: number | null
    wrong: number | null
    unanswered: number | null
    accuracy: number | null
    totalTimeTaken: number | null
  }

  export type TestResultMinAggregateOutputType = {
    id: number | null
    userId: number | null
    score: number | null
    totalMarks: number | null
    answered: number | null
    correct: number | null
    wrong: number | null
    unanswered: number | null
    accuracy: number | null
    totalTimeTaken: number | null
    createdAt: Date | null
  }

  export type TestResultMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    score: number | null
    totalMarks: number | null
    answered: number | null
    correct: number | null
    wrong: number | null
    unanswered: number | null
    accuracy: number | null
    totalTimeTaken: number | null
    createdAt: Date | null
  }

  export type TestResultCountAggregateOutputType = {
    id: number
    userId: number
    score: number
    totalMarks: number
    answered: number
    correct: number
    wrong: number
    unanswered: number
    accuracy: number
    totalTimeTaken: number
    resultsByType: number
    resultsByChapter: number
    createdAt: number
    _all: number
  }


  export type TestResultAvgAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    totalMarks?: true
    answered?: true
    correct?: true
    wrong?: true
    unanswered?: true
    accuracy?: true
    totalTimeTaken?: true
  }

  export type TestResultSumAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    totalMarks?: true
    answered?: true
    correct?: true
    wrong?: true
    unanswered?: true
    accuracy?: true
    totalTimeTaken?: true
  }

  export type TestResultMinAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    totalMarks?: true
    answered?: true
    correct?: true
    wrong?: true
    unanswered?: true
    accuracy?: true
    totalTimeTaken?: true
    createdAt?: true
  }

  export type TestResultMaxAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    totalMarks?: true
    answered?: true
    correct?: true
    wrong?: true
    unanswered?: true
    accuracy?: true
    totalTimeTaken?: true
    createdAt?: true
  }

  export type TestResultCountAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    totalMarks?: true
    answered?: true
    correct?: true
    wrong?: true
    unanswered?: true
    accuracy?: true
    totalTimeTaken?: true
    resultsByType?: true
    resultsByChapter?: true
    createdAt?: true
    _all?: true
  }

  export type TestResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestResult to aggregate.
     */
    where?: TestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResults to fetch.
     */
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestResults
    **/
    _count?: true | TestResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestResultMaxAggregateInputType
  }

  export type GetTestResultAggregateType<T extends TestResultAggregateArgs> = {
        [P in keyof T & keyof AggregateTestResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestResult[P]>
      : GetScalarType<T[P], AggregateTestResult[P]>
  }




  export type TestResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestResultWhereInput
    orderBy?: TestResultOrderByWithAggregationInput | TestResultOrderByWithAggregationInput[]
    by: TestResultScalarFieldEnum[] | TestResultScalarFieldEnum
    having?: TestResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestResultCountAggregateInputType | true
    _avg?: TestResultAvgAggregateInputType
    _sum?: TestResultSumAggregateInputType
    _min?: TestResultMinAggregateInputType
    _max?: TestResultMaxAggregateInputType
  }

  export type TestResultGroupByOutputType = {
    id: number
    userId: number
    score: number
    totalMarks: number
    answered: number
    correct: number
    wrong: number
    unanswered: number
    accuracy: number
    totalTimeTaken: number
    resultsByType: JsonValue
    resultsByChapter: JsonValue
    createdAt: Date
    _count: TestResultCountAggregateOutputType | null
    _avg: TestResultAvgAggregateOutputType | null
    _sum: TestResultSumAggregateOutputType | null
    _min: TestResultMinAggregateOutputType | null
    _max: TestResultMaxAggregateOutputType | null
  }

  type GetTestResultGroupByPayload<T extends TestResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestResultGroupByOutputType[P]>
            : GetScalarType<T[P], TestResultGroupByOutputType[P]>
        }
      >
    >


  export type TestResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    score?: boolean
    totalMarks?: boolean
    answered?: boolean
    correct?: boolean
    wrong?: boolean
    unanswered?: boolean
    accuracy?: boolean
    totalTimeTaken?: boolean
    resultsByType?: boolean
    resultsByChapter?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testResult"]>



  export type TestResultSelectScalar = {
    id?: boolean
    userId?: boolean
    score?: boolean
    totalMarks?: boolean
    answered?: boolean
    correct?: boolean
    wrong?: boolean
    unanswered?: boolean
    accuracy?: boolean
    totalTimeTaken?: boolean
    resultsByType?: boolean
    resultsByChapter?: boolean
    createdAt?: boolean
  }

  export type TestResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "score" | "totalMarks" | "answered" | "correct" | "wrong" | "unanswered" | "accuracy" | "totalTimeTaken" | "resultsByType" | "resultsByChapter" | "createdAt", ExtArgs["result"]["testResult"]>
  export type TestResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TestResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestResult"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      score: number
      totalMarks: number
      answered: number
      correct: number
      wrong: number
      unanswered: number
      accuracy: number
      totalTimeTaken: number
      resultsByType: Prisma.JsonValue
      resultsByChapter: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["testResult"]>
    composites: {}
  }

  type TestResultGetPayload<S extends boolean | null | undefined | TestResultDefaultArgs> = $Result.GetResult<Prisma.$TestResultPayload, S>

  type TestResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestResultCountAggregateInputType | true
    }

  export interface TestResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestResult'], meta: { name: 'TestResult' } }
    /**
     * Find zero or one TestResult that matches the filter.
     * @param {TestResultFindUniqueArgs} args - Arguments to find a TestResult
     * @example
     * // Get one TestResult
     * const testResult = await prisma.testResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestResultFindUniqueArgs>(args: SelectSubset<T, TestResultFindUniqueArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TestResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestResultFindUniqueOrThrowArgs} args - Arguments to find a TestResult
     * @example
     * // Get one TestResult
     * const testResult = await prisma.testResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestResultFindUniqueOrThrowArgs>(args: SelectSubset<T, TestResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TestResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultFindFirstArgs} args - Arguments to find a TestResult
     * @example
     * // Get one TestResult
     * const testResult = await prisma.testResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestResultFindFirstArgs>(args?: SelectSubset<T, TestResultFindFirstArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TestResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultFindFirstOrThrowArgs} args - Arguments to find a TestResult
     * @example
     * // Get one TestResult
     * const testResult = await prisma.testResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestResultFindFirstOrThrowArgs>(args?: SelectSubset<T, TestResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TestResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestResults
     * const testResults = await prisma.testResult.findMany()
     * 
     * // Get first 10 TestResults
     * const testResults = await prisma.testResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testResultWithIdOnly = await prisma.testResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestResultFindManyArgs>(args?: SelectSubset<T, TestResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TestResult.
     * @param {TestResultCreateArgs} args - Arguments to create a TestResult.
     * @example
     * // Create one TestResult
     * const TestResult = await prisma.testResult.create({
     *   data: {
     *     // ... data to create a TestResult
     *   }
     * })
     * 
     */
    create<T extends TestResultCreateArgs>(args: SelectSubset<T, TestResultCreateArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TestResults.
     * @param {TestResultCreateManyArgs} args - Arguments to create many TestResults.
     * @example
     * // Create many TestResults
     * const testResult = await prisma.testResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestResultCreateManyArgs>(args?: SelectSubset<T, TestResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TestResult.
     * @param {TestResultDeleteArgs} args - Arguments to delete one TestResult.
     * @example
     * // Delete one TestResult
     * const TestResult = await prisma.testResult.delete({
     *   where: {
     *     // ... filter to delete one TestResult
     *   }
     * })
     * 
     */
    delete<T extends TestResultDeleteArgs>(args: SelectSubset<T, TestResultDeleteArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TestResult.
     * @param {TestResultUpdateArgs} args - Arguments to update one TestResult.
     * @example
     * // Update one TestResult
     * const testResult = await prisma.testResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestResultUpdateArgs>(args: SelectSubset<T, TestResultUpdateArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TestResults.
     * @param {TestResultDeleteManyArgs} args - Arguments to filter TestResults to delete.
     * @example
     * // Delete a few TestResults
     * const { count } = await prisma.testResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestResultDeleteManyArgs>(args?: SelectSubset<T, TestResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestResults
     * const testResult = await prisma.testResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestResultUpdateManyArgs>(args: SelectSubset<T, TestResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestResult.
     * @param {TestResultUpsertArgs} args - Arguments to update or create a TestResult.
     * @example
     * // Update or create a TestResult
     * const testResult = await prisma.testResult.upsert({
     *   create: {
     *     // ... data to create a TestResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestResult we want to update
     *   }
     * })
     */
    upsert<T extends TestResultUpsertArgs>(args: SelectSubset<T, TestResultUpsertArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultCountArgs} args - Arguments to filter TestResults to count.
     * @example
     * // Count the number of TestResults
     * const count = await prisma.testResult.count({
     *   where: {
     *     // ... the filter for the TestResults we want to count
     *   }
     * })
    **/
    count<T extends TestResultCountArgs>(
      args?: Subset<T, TestResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestResultAggregateArgs>(args: Subset<T, TestResultAggregateArgs>): Prisma.PrismaPromise<GetTestResultAggregateType<T>>

    /**
     * Group by TestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestResultGroupByArgs['orderBy'] }
        : { orderBy?: TestResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestResult model
   */
  readonly fields: TestResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestResult model
   */ 
  interface TestResultFieldRefs {
    readonly id: FieldRef<"TestResult", 'Int'>
    readonly userId: FieldRef<"TestResult", 'Int'>
    readonly score: FieldRef<"TestResult", 'Int'>
    readonly totalMarks: FieldRef<"TestResult", 'Int'>
    readonly answered: FieldRef<"TestResult", 'Int'>
    readonly correct: FieldRef<"TestResult", 'Int'>
    readonly wrong: FieldRef<"TestResult", 'Int'>
    readonly unanswered: FieldRef<"TestResult", 'Int'>
    readonly accuracy: FieldRef<"TestResult", 'Float'>
    readonly totalTimeTaken: FieldRef<"TestResult", 'Int'>
    readonly resultsByType: FieldRef<"TestResult", 'Json'>
    readonly resultsByChapter: FieldRef<"TestResult", 'Json'>
    readonly createdAt: FieldRef<"TestResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestResult findUnique
   */
  export type TestResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * Filter, which TestResult to fetch.
     */
    where: TestResultWhereUniqueInput
  }

  /**
   * TestResult findUniqueOrThrow
   */
  export type TestResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * Filter, which TestResult to fetch.
     */
    where: TestResultWhereUniqueInput
  }

  /**
   * TestResult findFirst
   */
  export type TestResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * Filter, which TestResult to fetch.
     */
    where?: TestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResults to fetch.
     */
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestResults.
     */
    cursor?: TestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestResults.
     */
    distinct?: TestResultScalarFieldEnum | TestResultScalarFieldEnum[]
  }

  /**
   * TestResult findFirstOrThrow
   */
  export type TestResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * Filter, which TestResult to fetch.
     */
    where?: TestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResults to fetch.
     */
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestResults.
     */
    cursor?: TestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestResults.
     */
    distinct?: TestResultScalarFieldEnum | TestResultScalarFieldEnum[]
  }

  /**
   * TestResult findMany
   */
  export type TestResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * Filter, which TestResults to fetch.
     */
    where?: TestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResults to fetch.
     */
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestResults.
     */
    cursor?: TestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResults.
     */
    skip?: number
    distinct?: TestResultScalarFieldEnum | TestResultScalarFieldEnum[]
  }

  /**
   * TestResult create
   */
  export type TestResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * The data needed to create a TestResult.
     */
    data: XOR<TestResultCreateInput, TestResultUncheckedCreateInput>
  }

  /**
   * TestResult createMany
   */
  export type TestResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestResults.
     */
    data: TestResultCreateManyInput | TestResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestResult update
   */
  export type TestResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * The data needed to update a TestResult.
     */
    data: XOR<TestResultUpdateInput, TestResultUncheckedUpdateInput>
    /**
     * Choose, which TestResult to update.
     */
    where: TestResultWhereUniqueInput
  }

  /**
   * TestResult updateMany
   */
  export type TestResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestResults.
     */
    data: XOR<TestResultUpdateManyMutationInput, TestResultUncheckedUpdateManyInput>
    /**
     * Filter which TestResults to update
     */
    where?: TestResultWhereInput
    /**
     * Limit how many TestResults to update.
     */
    limit?: number
  }

  /**
   * TestResult upsert
   */
  export type TestResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * The filter to search for the TestResult to update in case it exists.
     */
    where: TestResultWhereUniqueInput
    /**
     * In case the TestResult found by the `where` argument doesn't exist, create a new TestResult with this data.
     */
    create: XOR<TestResultCreateInput, TestResultUncheckedCreateInput>
    /**
     * In case the TestResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestResultUpdateInput, TestResultUncheckedUpdateInput>
  }

  /**
   * TestResult delete
   */
  export type TestResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * Filter which TestResult to delete.
     */
    where: TestResultWhereUniqueInput
  }

  /**
   * TestResult deleteMany
   */
  export type TestResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestResults to delete
     */
    where?: TestResultWhereInput
    /**
     * Limit how many TestResults to delete.
     */
    limit?: number
  }

  /**
   * TestResult without action
   */
  export type TestResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    phoneNumber: 'phoneNumber',
    age: 'age',
    gender: 'gender',
    profile: 'profile'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const QuestionTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId',
    createdAt: 'createdAt'
  };

  export type QuestionTypeScalarFieldEnum = (typeof QuestionTypeScalarFieldEnum)[keyof typeof QuestionTypeScalarFieldEnum]


  export const PortionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type PortionScalarFieldEnum = (typeof PortionScalarFieldEnum)[keyof typeof PortionScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    portionId: 'portionId',
    createdAt: 'createdAt'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const ChapterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subjectId: 'subjectId',
    createdAt: 'createdAt'
  };

  export type ChapterScalarFieldEnum = (typeof ChapterScalarFieldEnum)[keyof typeof ChapterScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    name: 'name',
    chapterId: 'chapterId',
    createdAt: 'createdAt'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    questionTypeId: 'questionTypeId',
    portionId: 'portionId',
    subjectId: 'subjectId',
    chapterId: 'chapterId',
    topicId: 'topicId',
    question: 'question',
    image: 'image',
    optionA: 'optionA',
    optionB: 'optionB',
    optionC: 'optionC',
    optionD: 'optionD',
    correctOption: 'correctOption',
    hint: 'hint',
    hintImage: 'hintImage',
    createdAt: 'createdAt'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const PdfScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    portionId: 'portionId',
    subjectId: 'subjectId',
    chapterId: 'chapterId',
    topicId: 'topicId',
    createdAt: 'createdAt'
  };

  export type PdfScalarFieldEnum = (typeof PdfScalarFieldEnum)[keyof typeof PdfScalarFieldEnum]


  export const TestResultScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    score: 'score',
    totalMarks: 'totalMarks',
    answered: 'answered',
    correct: 'correct',
    wrong: 'wrong',
    unanswered: 'unanswered',
    accuracy: 'accuracy',
    totalTimeTaken: 'totalTimeTaken',
    resultsByType: 'resultsByType',
    resultsByChapter: 'resultsByChapter',
    createdAt: 'createdAt'
  };

  export type TestResultScalarFieldEnum = (typeof TestResultScalarFieldEnum)[keyof typeof TestResultScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    phoneNumber: 'phoneNumber',
    gender: 'gender',
    profile: 'profile'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const questionTypeOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type questionTypeOrderByRelevanceFieldEnum = (typeof questionTypeOrderByRelevanceFieldEnum)[keyof typeof questionTypeOrderByRelevanceFieldEnum]


  export const portionOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type portionOrderByRelevanceFieldEnum = (typeof portionOrderByRelevanceFieldEnum)[keyof typeof portionOrderByRelevanceFieldEnum]


  export const subjectOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type subjectOrderByRelevanceFieldEnum = (typeof subjectOrderByRelevanceFieldEnum)[keyof typeof subjectOrderByRelevanceFieldEnum]


  export const chapterOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type chapterOrderByRelevanceFieldEnum = (typeof chapterOrderByRelevanceFieldEnum)[keyof typeof chapterOrderByRelevanceFieldEnum]


  export const topicOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type topicOrderByRelevanceFieldEnum = (typeof topicOrderByRelevanceFieldEnum)[keyof typeof topicOrderByRelevanceFieldEnum]


  export const questionOrderByRelevanceFieldEnum: {
    question: 'question',
    image: 'image',
    optionA: 'optionA',
    optionB: 'optionB',
    optionC: 'optionC',
    optionD: 'optionD',
    correctOption: 'correctOption',
    hint: 'hint',
    hintImage: 'hintImage'
  };

  export type questionOrderByRelevanceFieldEnum = (typeof questionOrderByRelevanceFieldEnum)[keyof typeof questionOrderByRelevanceFieldEnum]


  export const PdfOrderByRelevanceFieldEnum: {
    name: 'name',
    url: 'url'
  };

  export type PdfOrderByRelevanceFieldEnum = (typeof PdfOrderByRelevanceFieldEnum)[keyof typeof PdfOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    age?: IntNullableFilter<"User"> | number | null
    gender?: StringNullableFilter<"User"> | string | null
    profile?: StringNullableFilter<"User"> | string | null
    testResults?: TestResultListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    profile?: SortOrderInput | SortOrder
    testResults?: TestResultOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    phoneNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    age?: IntNullableFilter<"User"> | number | null
    gender?: StringNullableFilter<"User"> | string | null
    profile?: StringNullableFilter<"User"> | string | null
    testResults?: TestResultListRelationFilter
  }, "id" | "email" | "phoneNumber">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    profile?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    age?: IntNullableWithAggregatesFilter<"User"> | number | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    profile?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type questionTypeWhereInput = {
    AND?: questionTypeWhereInput | questionTypeWhereInput[]
    OR?: questionTypeWhereInput[]
    NOT?: questionTypeWhereInput | questionTypeWhereInput[]
    id?: IntFilter<"questionType"> | number
    name?: StringFilter<"questionType"> | string
    parentId?: IntNullableFilter<"questionType"> | number | null
    createdAt?: DateTimeFilter<"questionType"> | Date | string
    parent?: XOR<QuestionTypeNullableScalarRelationFilter, questionTypeWhereInput> | null
    other_questionType?: QuestionTypeListRelationFilter
    question?: QuestionListRelationFilter
  }

  export type questionTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    parent?: questionTypeOrderByWithRelationInput
    other_questionType?: questionTypeOrderByRelationAggregateInput
    question?: questionOrderByRelationAggregateInput
    _relevance?: questionTypeOrderByRelevanceInput
  }

  export type questionTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: questionTypeWhereInput | questionTypeWhereInput[]
    OR?: questionTypeWhereInput[]
    NOT?: questionTypeWhereInput | questionTypeWhereInput[]
    name?: StringFilter<"questionType"> | string
    parentId?: IntNullableFilter<"questionType"> | number | null
    createdAt?: DateTimeFilter<"questionType"> | Date | string
    parent?: XOR<QuestionTypeNullableScalarRelationFilter, questionTypeWhereInput> | null
    other_questionType?: QuestionTypeListRelationFilter
    question?: QuestionListRelationFilter
  }, "id">

  export type questionTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: questionTypeCountOrderByAggregateInput
    _avg?: questionTypeAvgOrderByAggregateInput
    _max?: questionTypeMaxOrderByAggregateInput
    _min?: questionTypeMinOrderByAggregateInput
    _sum?: questionTypeSumOrderByAggregateInput
  }

  export type questionTypeScalarWhereWithAggregatesInput = {
    AND?: questionTypeScalarWhereWithAggregatesInput | questionTypeScalarWhereWithAggregatesInput[]
    OR?: questionTypeScalarWhereWithAggregatesInput[]
    NOT?: questionTypeScalarWhereWithAggregatesInput | questionTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"questionType"> | number
    name?: StringWithAggregatesFilter<"questionType"> | string
    parentId?: IntNullableWithAggregatesFilter<"questionType"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"questionType"> | Date | string
  }

  export type portionWhereInput = {
    AND?: portionWhereInput | portionWhereInput[]
    OR?: portionWhereInput[]
    NOT?: portionWhereInput | portionWhereInput[]
    id?: IntFilter<"portion"> | number
    name?: StringFilter<"portion"> | string
    createdAt?: DateTimeFilter<"portion"> | Date | string
    subjects?: SubjectListRelationFilter
    questions?: QuestionListRelationFilter
    pdfs?: PdfListRelationFilter
  }

  export type portionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    subjects?: subjectOrderByRelationAggregateInput
    questions?: questionOrderByRelationAggregateInput
    pdfs?: PdfOrderByRelationAggregateInput
    _relevance?: portionOrderByRelevanceInput
  }

  export type portionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: portionWhereInput | portionWhereInput[]
    OR?: portionWhereInput[]
    NOT?: portionWhereInput | portionWhereInput[]
    name?: StringFilter<"portion"> | string
    createdAt?: DateTimeFilter<"portion"> | Date | string
    subjects?: SubjectListRelationFilter
    questions?: QuestionListRelationFilter
    pdfs?: PdfListRelationFilter
  }, "id">

  export type portionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: portionCountOrderByAggregateInput
    _avg?: portionAvgOrderByAggregateInput
    _max?: portionMaxOrderByAggregateInput
    _min?: portionMinOrderByAggregateInput
    _sum?: portionSumOrderByAggregateInput
  }

  export type portionScalarWhereWithAggregatesInput = {
    AND?: portionScalarWhereWithAggregatesInput | portionScalarWhereWithAggregatesInput[]
    OR?: portionScalarWhereWithAggregatesInput[]
    NOT?: portionScalarWhereWithAggregatesInput | portionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"portion"> | number
    name?: StringWithAggregatesFilter<"portion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"portion"> | Date | string
  }

  export type subjectWhereInput = {
    AND?: subjectWhereInput | subjectWhereInput[]
    OR?: subjectWhereInput[]
    NOT?: subjectWhereInput | subjectWhereInput[]
    id?: IntFilter<"subject"> | number
    name?: StringFilter<"subject"> | string
    portionId?: IntFilter<"subject"> | number
    createdAt?: DateTimeFilter<"subject"> | Date | string
    chapters?: ChapterListRelationFilter
    questions?: QuestionListRelationFilter
    pdfs?: PdfListRelationFilter
    portion?: XOR<PortionScalarRelationFilter, portionWhereInput>
  }

  export type subjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    portionId?: SortOrder
    createdAt?: SortOrder
    chapters?: chapterOrderByRelationAggregateInput
    questions?: questionOrderByRelationAggregateInput
    pdfs?: PdfOrderByRelationAggregateInput
    portion?: portionOrderByWithRelationInput
    _relevance?: subjectOrderByRelevanceInput
  }

  export type subjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: subjectWhereInput | subjectWhereInput[]
    OR?: subjectWhereInput[]
    NOT?: subjectWhereInput | subjectWhereInput[]
    name?: StringFilter<"subject"> | string
    portionId?: IntFilter<"subject"> | number
    createdAt?: DateTimeFilter<"subject"> | Date | string
    chapters?: ChapterListRelationFilter
    questions?: QuestionListRelationFilter
    pdfs?: PdfListRelationFilter
    portion?: XOR<PortionScalarRelationFilter, portionWhereInput>
  }, "id">

  export type subjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    portionId?: SortOrder
    createdAt?: SortOrder
    _count?: subjectCountOrderByAggregateInput
    _avg?: subjectAvgOrderByAggregateInput
    _max?: subjectMaxOrderByAggregateInput
    _min?: subjectMinOrderByAggregateInput
    _sum?: subjectSumOrderByAggregateInput
  }

  export type subjectScalarWhereWithAggregatesInput = {
    AND?: subjectScalarWhereWithAggregatesInput | subjectScalarWhereWithAggregatesInput[]
    OR?: subjectScalarWhereWithAggregatesInput[]
    NOT?: subjectScalarWhereWithAggregatesInput | subjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"subject"> | number
    name?: StringWithAggregatesFilter<"subject"> | string
    portionId?: IntWithAggregatesFilter<"subject"> | number
    createdAt?: DateTimeWithAggregatesFilter<"subject"> | Date | string
  }

  export type chapterWhereInput = {
    AND?: chapterWhereInput | chapterWhereInput[]
    OR?: chapterWhereInput[]
    NOT?: chapterWhereInput | chapterWhereInput[]
    id?: IntFilter<"chapter"> | number
    name?: StringFilter<"chapter"> | string
    subjectId?: IntFilter<"chapter"> | number
    createdAt?: DateTimeFilter<"chapter"> | Date | string
    questions?: QuestionListRelationFilter
    pdfs?: PdfListRelationFilter
    subject?: XOR<SubjectScalarRelationFilter, subjectWhereInput>
    topics?: TopicListRelationFilter
  }

  export type chapterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    questions?: questionOrderByRelationAggregateInput
    pdfs?: PdfOrderByRelationAggregateInput
    subject?: subjectOrderByWithRelationInput
    topics?: topicOrderByRelationAggregateInput
    _relevance?: chapterOrderByRelevanceInput
  }

  export type chapterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: chapterWhereInput | chapterWhereInput[]
    OR?: chapterWhereInput[]
    NOT?: chapterWhereInput | chapterWhereInput[]
    name?: StringFilter<"chapter"> | string
    subjectId?: IntFilter<"chapter"> | number
    createdAt?: DateTimeFilter<"chapter"> | Date | string
    questions?: QuestionListRelationFilter
    pdfs?: PdfListRelationFilter
    subject?: XOR<SubjectScalarRelationFilter, subjectWhereInput>
    topics?: TopicListRelationFilter
  }, "id">

  export type chapterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    _count?: chapterCountOrderByAggregateInput
    _avg?: chapterAvgOrderByAggregateInput
    _max?: chapterMaxOrderByAggregateInput
    _min?: chapterMinOrderByAggregateInput
    _sum?: chapterSumOrderByAggregateInput
  }

  export type chapterScalarWhereWithAggregatesInput = {
    AND?: chapterScalarWhereWithAggregatesInput | chapterScalarWhereWithAggregatesInput[]
    OR?: chapterScalarWhereWithAggregatesInput[]
    NOT?: chapterScalarWhereWithAggregatesInput | chapterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"chapter"> | number
    name?: StringWithAggregatesFilter<"chapter"> | string
    subjectId?: IntWithAggregatesFilter<"chapter"> | number
    createdAt?: DateTimeWithAggregatesFilter<"chapter"> | Date | string
  }

  export type topicWhereInput = {
    AND?: topicWhereInput | topicWhereInput[]
    OR?: topicWhereInput[]
    NOT?: topicWhereInput | topicWhereInput[]
    id?: IntFilter<"topic"> | number
    name?: StringFilter<"topic"> | string
    chapterId?: IntFilter<"topic"> | number
    createdAt?: DateTimeFilter<"topic"> | Date | string
    questions?: QuestionListRelationFilter
    pdfs?: PdfListRelationFilter
    chapter?: XOR<ChapterScalarRelationFilter, chapterWhereInput>
  }

  export type topicOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    questions?: questionOrderByRelationAggregateInput
    pdfs?: PdfOrderByRelationAggregateInput
    chapter?: chapterOrderByWithRelationInput
    _relevance?: topicOrderByRelevanceInput
  }

  export type topicWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: topicWhereInput | topicWhereInput[]
    OR?: topicWhereInput[]
    NOT?: topicWhereInput | topicWhereInput[]
    name?: StringFilter<"topic"> | string
    chapterId?: IntFilter<"topic"> | number
    createdAt?: DateTimeFilter<"topic"> | Date | string
    questions?: QuestionListRelationFilter
    pdfs?: PdfListRelationFilter
    chapter?: XOR<ChapterScalarRelationFilter, chapterWhereInput>
  }, "id">

  export type topicOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    _count?: topicCountOrderByAggregateInput
    _avg?: topicAvgOrderByAggregateInput
    _max?: topicMaxOrderByAggregateInput
    _min?: topicMinOrderByAggregateInput
    _sum?: topicSumOrderByAggregateInput
  }

  export type topicScalarWhereWithAggregatesInput = {
    AND?: topicScalarWhereWithAggregatesInput | topicScalarWhereWithAggregatesInput[]
    OR?: topicScalarWhereWithAggregatesInput[]
    NOT?: topicScalarWhereWithAggregatesInput | topicScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"topic"> | number
    name?: StringWithAggregatesFilter<"topic"> | string
    chapterId?: IntWithAggregatesFilter<"topic"> | number
    createdAt?: DateTimeWithAggregatesFilter<"topic"> | Date | string
  }

  export type questionWhereInput = {
    AND?: questionWhereInput | questionWhereInput[]
    OR?: questionWhereInput[]
    NOT?: questionWhereInput | questionWhereInput[]
    id?: IntFilter<"question"> | number
    questionTypeId?: IntFilter<"question"> | number
    portionId?: IntFilter<"question"> | number
    subjectId?: IntFilter<"question"> | number
    chapterId?: IntFilter<"question"> | number
    topicId?: IntFilter<"question"> | number
    question?: StringFilter<"question"> | string
    image?: StringNullableFilter<"question"> | string | null
    optionA?: StringFilter<"question"> | string
    optionB?: StringFilter<"question"> | string
    optionC?: StringFilter<"question"> | string
    optionD?: StringFilter<"question"> | string
    correctOption?: StringFilter<"question"> | string
    hint?: StringNullableFilter<"question"> | string | null
    hintImage?: StringNullableFilter<"question"> | string | null
    createdAt?: DateTimeFilter<"question"> | Date | string
    questionType?: XOR<QuestionTypeScalarRelationFilter, questionTypeWhereInput>
    portion?: XOR<PortionScalarRelationFilter, portionWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, subjectWhereInput>
    chapter?: XOR<ChapterScalarRelationFilter, chapterWhereInput>
    topic?: XOR<TopicScalarRelationFilter, topicWhereInput>
  }

  export type questionOrderByWithRelationInput = {
    id?: SortOrder
    questionTypeId?: SortOrder
    portionId?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    topicId?: SortOrder
    question?: SortOrder
    image?: SortOrderInput | SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    hint?: SortOrderInput | SortOrder
    hintImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    questionType?: questionTypeOrderByWithRelationInput
    portion?: portionOrderByWithRelationInput
    subject?: subjectOrderByWithRelationInput
    chapter?: chapterOrderByWithRelationInput
    topic?: topicOrderByWithRelationInput
    _relevance?: questionOrderByRelevanceInput
  }

  export type questionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: questionWhereInput | questionWhereInput[]
    OR?: questionWhereInput[]
    NOT?: questionWhereInput | questionWhereInput[]
    questionTypeId?: IntFilter<"question"> | number
    portionId?: IntFilter<"question"> | number
    subjectId?: IntFilter<"question"> | number
    chapterId?: IntFilter<"question"> | number
    topicId?: IntFilter<"question"> | number
    question?: StringFilter<"question"> | string
    image?: StringNullableFilter<"question"> | string | null
    optionA?: StringFilter<"question"> | string
    optionB?: StringFilter<"question"> | string
    optionC?: StringFilter<"question"> | string
    optionD?: StringFilter<"question"> | string
    correctOption?: StringFilter<"question"> | string
    hint?: StringNullableFilter<"question"> | string | null
    hintImage?: StringNullableFilter<"question"> | string | null
    createdAt?: DateTimeFilter<"question"> | Date | string
    questionType?: XOR<QuestionTypeScalarRelationFilter, questionTypeWhereInput>
    portion?: XOR<PortionScalarRelationFilter, portionWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, subjectWhereInput>
    chapter?: XOR<ChapterScalarRelationFilter, chapterWhereInput>
    topic?: XOR<TopicScalarRelationFilter, topicWhereInput>
  }, "id">

  export type questionOrderByWithAggregationInput = {
    id?: SortOrder
    questionTypeId?: SortOrder
    portionId?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    topicId?: SortOrder
    question?: SortOrder
    image?: SortOrderInput | SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    hint?: SortOrderInput | SortOrder
    hintImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: questionCountOrderByAggregateInput
    _avg?: questionAvgOrderByAggregateInput
    _max?: questionMaxOrderByAggregateInput
    _min?: questionMinOrderByAggregateInput
    _sum?: questionSumOrderByAggregateInput
  }

  export type questionScalarWhereWithAggregatesInput = {
    AND?: questionScalarWhereWithAggregatesInput | questionScalarWhereWithAggregatesInput[]
    OR?: questionScalarWhereWithAggregatesInput[]
    NOT?: questionScalarWhereWithAggregatesInput | questionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"question"> | number
    questionTypeId?: IntWithAggregatesFilter<"question"> | number
    portionId?: IntWithAggregatesFilter<"question"> | number
    subjectId?: IntWithAggregatesFilter<"question"> | number
    chapterId?: IntWithAggregatesFilter<"question"> | number
    topicId?: IntWithAggregatesFilter<"question"> | number
    question?: StringWithAggregatesFilter<"question"> | string
    image?: StringNullableWithAggregatesFilter<"question"> | string | null
    optionA?: StringWithAggregatesFilter<"question"> | string
    optionB?: StringWithAggregatesFilter<"question"> | string
    optionC?: StringWithAggregatesFilter<"question"> | string
    optionD?: StringWithAggregatesFilter<"question"> | string
    correctOption?: StringWithAggregatesFilter<"question"> | string
    hint?: StringNullableWithAggregatesFilter<"question"> | string | null
    hintImage?: StringNullableWithAggregatesFilter<"question"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"question"> | Date | string
  }

  export type PdfWhereInput = {
    AND?: PdfWhereInput | PdfWhereInput[]
    OR?: PdfWhereInput[]
    NOT?: PdfWhereInput | PdfWhereInput[]
    id?: IntFilter<"Pdf"> | number
    name?: StringFilter<"Pdf"> | string
    url?: StringFilter<"Pdf"> | string
    portionId?: IntNullableFilter<"Pdf"> | number | null
    subjectId?: IntNullableFilter<"Pdf"> | number | null
    chapterId?: IntNullableFilter<"Pdf"> | number | null
    topicId?: IntNullableFilter<"Pdf"> | number | null
    createdAt?: DateTimeFilter<"Pdf"> | Date | string
    portion?: XOR<PortionNullableScalarRelationFilter, portionWhereInput> | null
    subject?: XOR<SubjectNullableScalarRelationFilter, subjectWhereInput> | null
    chapter?: XOR<ChapterNullableScalarRelationFilter, chapterWhereInput> | null
    topic?: XOR<TopicNullableScalarRelationFilter, topicWhereInput> | null
  }

  export type PdfOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    portionId?: SortOrderInput | SortOrder
    subjectId?: SortOrderInput | SortOrder
    chapterId?: SortOrderInput | SortOrder
    topicId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    portion?: portionOrderByWithRelationInput
    subject?: subjectOrderByWithRelationInput
    chapter?: chapterOrderByWithRelationInput
    topic?: topicOrderByWithRelationInput
    _relevance?: PdfOrderByRelevanceInput
  }

  export type PdfWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PdfWhereInput | PdfWhereInput[]
    OR?: PdfWhereInput[]
    NOT?: PdfWhereInput | PdfWhereInput[]
    name?: StringFilter<"Pdf"> | string
    url?: StringFilter<"Pdf"> | string
    portionId?: IntNullableFilter<"Pdf"> | number | null
    subjectId?: IntNullableFilter<"Pdf"> | number | null
    chapterId?: IntNullableFilter<"Pdf"> | number | null
    topicId?: IntNullableFilter<"Pdf"> | number | null
    createdAt?: DateTimeFilter<"Pdf"> | Date | string
    portion?: XOR<PortionNullableScalarRelationFilter, portionWhereInput> | null
    subject?: XOR<SubjectNullableScalarRelationFilter, subjectWhereInput> | null
    chapter?: XOR<ChapterNullableScalarRelationFilter, chapterWhereInput> | null
    topic?: XOR<TopicNullableScalarRelationFilter, topicWhereInput> | null
  }, "id">

  export type PdfOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    portionId?: SortOrderInput | SortOrder
    subjectId?: SortOrderInput | SortOrder
    chapterId?: SortOrderInput | SortOrder
    topicId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PdfCountOrderByAggregateInput
    _avg?: PdfAvgOrderByAggregateInput
    _max?: PdfMaxOrderByAggregateInput
    _min?: PdfMinOrderByAggregateInput
    _sum?: PdfSumOrderByAggregateInput
  }

  export type PdfScalarWhereWithAggregatesInput = {
    AND?: PdfScalarWhereWithAggregatesInput | PdfScalarWhereWithAggregatesInput[]
    OR?: PdfScalarWhereWithAggregatesInput[]
    NOT?: PdfScalarWhereWithAggregatesInput | PdfScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pdf"> | number
    name?: StringWithAggregatesFilter<"Pdf"> | string
    url?: StringWithAggregatesFilter<"Pdf"> | string
    portionId?: IntNullableWithAggregatesFilter<"Pdf"> | number | null
    subjectId?: IntNullableWithAggregatesFilter<"Pdf"> | number | null
    chapterId?: IntNullableWithAggregatesFilter<"Pdf"> | number | null
    topicId?: IntNullableWithAggregatesFilter<"Pdf"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Pdf"> | Date | string
  }

  export type TestResultWhereInput = {
    AND?: TestResultWhereInput | TestResultWhereInput[]
    OR?: TestResultWhereInput[]
    NOT?: TestResultWhereInput | TestResultWhereInput[]
    id?: IntFilter<"TestResult"> | number
    userId?: IntFilter<"TestResult"> | number
    score?: IntFilter<"TestResult"> | number
    totalMarks?: IntFilter<"TestResult"> | number
    answered?: IntFilter<"TestResult"> | number
    correct?: IntFilter<"TestResult"> | number
    wrong?: IntFilter<"TestResult"> | number
    unanswered?: IntFilter<"TestResult"> | number
    accuracy?: FloatFilter<"TestResult"> | number
    totalTimeTaken?: IntFilter<"TestResult"> | number
    resultsByType?: JsonFilter<"TestResult">
    resultsByChapter?: JsonFilter<"TestResult">
    createdAt?: DateTimeFilter<"TestResult"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TestResultOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    totalMarks?: SortOrder
    answered?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
    unanswered?: SortOrder
    accuracy?: SortOrder
    totalTimeTaken?: SortOrder
    resultsByType?: SortOrder
    resultsByChapter?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TestResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestResultWhereInput | TestResultWhereInput[]
    OR?: TestResultWhereInput[]
    NOT?: TestResultWhereInput | TestResultWhereInput[]
    userId?: IntFilter<"TestResult"> | number
    score?: IntFilter<"TestResult"> | number
    totalMarks?: IntFilter<"TestResult"> | number
    answered?: IntFilter<"TestResult"> | number
    correct?: IntFilter<"TestResult"> | number
    wrong?: IntFilter<"TestResult"> | number
    unanswered?: IntFilter<"TestResult"> | number
    accuracy?: FloatFilter<"TestResult"> | number
    totalTimeTaken?: IntFilter<"TestResult"> | number
    resultsByType?: JsonFilter<"TestResult">
    resultsByChapter?: JsonFilter<"TestResult">
    createdAt?: DateTimeFilter<"TestResult"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TestResultOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    totalMarks?: SortOrder
    answered?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
    unanswered?: SortOrder
    accuracy?: SortOrder
    totalTimeTaken?: SortOrder
    resultsByType?: SortOrder
    resultsByChapter?: SortOrder
    createdAt?: SortOrder
    _count?: TestResultCountOrderByAggregateInput
    _avg?: TestResultAvgOrderByAggregateInput
    _max?: TestResultMaxOrderByAggregateInput
    _min?: TestResultMinOrderByAggregateInput
    _sum?: TestResultSumOrderByAggregateInput
  }

  export type TestResultScalarWhereWithAggregatesInput = {
    AND?: TestResultScalarWhereWithAggregatesInput | TestResultScalarWhereWithAggregatesInput[]
    OR?: TestResultScalarWhereWithAggregatesInput[]
    NOT?: TestResultScalarWhereWithAggregatesInput | TestResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TestResult"> | number
    userId?: IntWithAggregatesFilter<"TestResult"> | number
    score?: IntWithAggregatesFilter<"TestResult"> | number
    totalMarks?: IntWithAggregatesFilter<"TestResult"> | number
    answered?: IntWithAggregatesFilter<"TestResult"> | number
    correct?: IntWithAggregatesFilter<"TestResult"> | number
    wrong?: IntWithAggregatesFilter<"TestResult"> | number
    unanswered?: IntWithAggregatesFilter<"TestResult"> | number
    accuracy?: FloatWithAggregatesFilter<"TestResult"> | number
    totalTimeTaken?: IntWithAggregatesFilter<"TestResult"> | number
    resultsByType?: JsonWithAggregatesFilter<"TestResult">
    resultsByChapter?: JsonWithAggregatesFilter<"TestResult">
    createdAt?: DateTimeWithAggregatesFilter<"TestResult"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    name?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    age?: number | null
    gender?: string | null
    profile?: string | null
    testResults?: TestResultCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    name?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    age?: number | null
    gender?: string | null
    profile?: string | null
    testResults?: TestResultUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    testResults?: TestResultUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    testResults?: TestResultUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    name?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    age?: number | null
    gender?: string | null
    profile?: string | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type questionTypeCreateInput = {
    name: string
    createdAt?: Date | string
    parent?: questionTypeCreateNestedOneWithoutOther_questionTypeInput
    other_questionType?: questionTypeCreateNestedManyWithoutParentInput
    question?: questionCreateNestedManyWithoutQuestionTypeInput
  }

  export type questionTypeUncheckedCreateInput = {
    id?: number
    name: string
    parentId?: number | null
    createdAt?: Date | string
    other_questionType?: questionTypeUncheckedCreateNestedManyWithoutParentInput
    question?: questionUncheckedCreateNestedManyWithoutQuestionTypeInput
  }

  export type questionTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: questionTypeUpdateOneWithoutOther_questionTypeNestedInput
    other_questionType?: questionTypeUpdateManyWithoutParentNestedInput
    question?: questionUpdateManyWithoutQuestionTypeNestedInput
  }

  export type questionTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    other_questionType?: questionTypeUncheckedUpdateManyWithoutParentNestedInput
    question?: questionUncheckedUpdateManyWithoutQuestionTypeNestedInput
  }

  export type questionTypeCreateManyInput = {
    id?: number
    name: string
    parentId?: number | null
    createdAt?: Date | string
  }

  export type questionTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type portionCreateInput = {
    name: string
    createdAt?: Date | string
    subjects?: subjectCreateNestedManyWithoutPortionInput
    questions?: questionCreateNestedManyWithoutPortionInput
    pdfs?: PdfCreateNestedManyWithoutPortionInput
  }

  export type portionUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    subjects?: subjectUncheckedCreateNestedManyWithoutPortionInput
    questions?: questionUncheckedCreateNestedManyWithoutPortionInput
    pdfs?: PdfUncheckedCreateNestedManyWithoutPortionInput
  }

  export type portionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: subjectUpdateManyWithoutPortionNestedInput
    questions?: questionUpdateManyWithoutPortionNestedInput
    pdfs?: PdfUpdateManyWithoutPortionNestedInput
  }

  export type portionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: subjectUncheckedUpdateManyWithoutPortionNestedInput
    questions?: questionUncheckedUpdateManyWithoutPortionNestedInput
    pdfs?: PdfUncheckedUpdateManyWithoutPortionNestedInput
  }

  export type portionCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type portionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type portionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectCreateInput = {
    name: string
    createdAt?: Date | string
    chapters?: chapterCreateNestedManyWithoutSubjectInput
    questions?: questionCreateNestedManyWithoutSubjectInput
    pdfs?: PdfCreateNestedManyWithoutSubjectInput
    portion: portionCreateNestedOneWithoutSubjectsInput
  }

  export type subjectUncheckedCreateInput = {
    id?: number
    name: string
    portionId: number
    createdAt?: Date | string
    chapters?: chapterUncheckedCreateNestedManyWithoutSubjectInput
    questions?: questionUncheckedCreateNestedManyWithoutSubjectInput
    pdfs?: PdfUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: chapterUpdateManyWithoutSubjectNestedInput
    questions?: questionUpdateManyWithoutSubjectNestedInput
    pdfs?: PdfUpdateManyWithoutSubjectNestedInput
    portion?: portionUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type subjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    portionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: chapterUncheckedUpdateManyWithoutSubjectNestedInput
    questions?: questionUncheckedUpdateManyWithoutSubjectNestedInput
    pdfs?: PdfUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type subjectCreateManyInput = {
    id?: number
    name: string
    portionId: number
    createdAt?: Date | string
  }

  export type subjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    portionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chapterCreateInput = {
    name: string
    createdAt?: Date | string
    questions?: questionCreateNestedManyWithoutChapterInput
    pdfs?: PdfCreateNestedManyWithoutChapterInput
    subject: subjectCreateNestedOneWithoutChaptersInput
    topics?: topicCreateNestedManyWithoutChapterInput
  }

  export type chapterUncheckedCreateInput = {
    id?: number
    name: string
    subjectId: number
    createdAt?: Date | string
    questions?: questionUncheckedCreateNestedManyWithoutChapterInput
    pdfs?: PdfUncheckedCreateNestedManyWithoutChapterInput
    topics?: topicUncheckedCreateNestedManyWithoutChapterInput
  }

  export type chapterUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUpdateManyWithoutChapterNestedInput
    pdfs?: PdfUpdateManyWithoutChapterNestedInput
    subject?: subjectUpdateOneRequiredWithoutChaptersNestedInput
    topics?: topicUpdateManyWithoutChapterNestedInput
  }

  export type chapterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subjectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUncheckedUpdateManyWithoutChapterNestedInput
    pdfs?: PdfUncheckedUpdateManyWithoutChapterNestedInput
    topics?: topicUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type chapterCreateManyInput = {
    id?: number
    name: string
    subjectId: number
    createdAt?: Date | string
  }

  export type chapterUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chapterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subjectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type topicCreateInput = {
    name: string
    createdAt?: Date | string
    questions?: questionCreateNestedManyWithoutTopicInput
    pdfs?: PdfCreateNestedManyWithoutTopicInput
    chapter: chapterCreateNestedOneWithoutTopicsInput
  }

  export type topicUncheckedCreateInput = {
    id?: number
    name: string
    chapterId: number
    createdAt?: Date | string
    questions?: questionUncheckedCreateNestedManyWithoutTopicInput
    pdfs?: PdfUncheckedCreateNestedManyWithoutTopicInput
  }

  export type topicUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUpdateManyWithoutTopicNestedInput
    pdfs?: PdfUpdateManyWithoutTopicNestedInput
    chapter?: chapterUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type topicUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    chapterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUncheckedUpdateManyWithoutTopicNestedInput
    pdfs?: PdfUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type topicCreateManyInput = {
    id?: number
    name: string
    chapterId: number
    createdAt?: Date | string
  }

  export type topicUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type topicUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    chapterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionCreateInput = {
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
    questionType: questionTypeCreateNestedOneWithoutQuestionInput
    portion: portionCreateNestedOneWithoutQuestionsInput
    subject: subjectCreateNestedOneWithoutQuestionsInput
    chapter: chapterCreateNestedOneWithoutQuestionsInput
    topic: topicCreateNestedOneWithoutQuestionsInput
  }

  export type questionUncheckedCreateInput = {
    id?: number
    questionTypeId: number
    portionId: number
    subjectId: number
    chapterId: number
    topicId: number
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
  }

  export type questionUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionType?: questionTypeUpdateOneRequiredWithoutQuestionNestedInput
    portion?: portionUpdateOneRequiredWithoutQuestionsNestedInput
    subject?: subjectUpdateOneRequiredWithoutQuestionsNestedInput
    chapter?: chapterUpdateOneRequiredWithoutQuestionsNestedInput
    topic?: topicUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type questionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionTypeId?: IntFieldUpdateOperationsInput | number
    portionId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionCreateManyInput = {
    id?: number
    questionTypeId: number
    portionId: number
    subjectId: number
    chapterId: number
    topicId: number
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
  }

  export type questionUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionTypeId?: IntFieldUpdateOperationsInput | number
    portionId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfCreateInput = {
    name: string
    url: string
    createdAt?: Date | string
    portion?: portionCreateNestedOneWithoutPdfsInput
    subject?: subjectCreateNestedOneWithoutPdfsInput
    chapter?: chapterCreateNestedOneWithoutPdfsInput
    topic?: topicCreateNestedOneWithoutPdfsInput
  }

  export type PdfUncheckedCreateInput = {
    id?: number
    name: string
    url: string
    portionId?: number | null
    subjectId?: number | null
    chapterId?: number | null
    topicId?: number | null
    createdAt?: Date | string
  }

  export type PdfUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portion?: portionUpdateOneWithoutPdfsNestedInput
    subject?: subjectUpdateOneWithoutPdfsNestedInput
    chapter?: chapterUpdateOneWithoutPdfsNestedInput
    topic?: topicUpdateOneWithoutPdfsNestedInput
  }

  export type PdfUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    portionId?: NullableIntFieldUpdateOperationsInput | number | null
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfCreateManyInput = {
    id?: number
    name: string
    url: string
    portionId?: number | null
    subjectId?: number | null
    chapterId?: number | null
    topicId?: number | null
    createdAt?: Date | string
  }

  export type PdfUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    portionId?: NullableIntFieldUpdateOperationsInput | number | null
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultCreateInput = {
    score: number
    totalMarks: number
    answered: number
    correct: number
    wrong: number
    unanswered: number
    accuracy: number
    totalTimeTaken: number
    resultsByType: JsonNullValueInput | InputJsonValue
    resultsByChapter: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTestResultsInput
  }

  export type TestResultUncheckedCreateInput = {
    id?: number
    userId: number
    score: number
    totalMarks: number
    answered: number
    correct: number
    wrong: number
    unanswered: number
    accuracy: number
    totalTimeTaken: number
    resultsByType: JsonNullValueInput | InputJsonValue
    resultsByChapter: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TestResultUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    answered?: IntFieldUpdateOperationsInput | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    totalTimeTaken?: IntFieldUpdateOperationsInput | number
    resultsByType?: JsonNullValueInput | InputJsonValue
    resultsByChapter?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTestResultsNestedInput
  }

  export type TestResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    answered?: IntFieldUpdateOperationsInput | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    totalTimeTaken?: IntFieldUpdateOperationsInput | number
    resultsByType?: JsonNullValueInput | InputJsonValue
    resultsByChapter?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultCreateManyInput = {
    id?: number
    userId: number
    score: number
    totalMarks: number
    answered: number
    correct: number
    wrong: number
    unanswered: number
    accuracy: number
    totalTimeTaken: number
    resultsByType: JsonNullValueInput | InputJsonValue
    resultsByChapter: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TestResultUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    answered?: IntFieldUpdateOperationsInput | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    totalTimeTaken?: IntFieldUpdateOperationsInput | number
    resultsByType?: JsonNullValueInput | InputJsonValue
    resultsByChapter?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    answered?: IntFieldUpdateOperationsInput | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    totalTimeTaken?: IntFieldUpdateOperationsInput | number
    resultsByType?: JsonNullValueInput | InputJsonValue
    resultsByChapter?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TestResultListRelationFilter = {
    every?: TestResultWhereInput
    some?: TestResultWhereInput
    none?: TestResultWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TestResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    profile?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    profile?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    profile?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type QuestionTypeNullableScalarRelationFilter = {
    is?: questionTypeWhereInput | null
    isNot?: questionTypeWhereInput | null
  }

  export type QuestionTypeListRelationFilter = {
    every?: questionTypeWhereInput
    some?: questionTypeWhereInput
    none?: questionTypeWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: questionWhereInput
    some?: questionWhereInput
    none?: questionWhereInput
  }

  export type questionTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type questionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type questionTypeOrderByRelevanceInput = {
    fields: questionTypeOrderByRelevanceFieldEnum | questionTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type questionTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
  }

  export type questionTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type questionTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
  }

  export type questionTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
  }

  export type questionTypeSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type SubjectListRelationFilter = {
    every?: subjectWhereInput
    some?: subjectWhereInput
    none?: subjectWhereInput
  }

  export type PdfListRelationFilter = {
    every?: PdfWhereInput
    some?: PdfWhereInput
    none?: PdfWhereInput
  }

  export type subjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PdfOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type portionOrderByRelevanceInput = {
    fields: portionOrderByRelevanceFieldEnum | portionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type portionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type portionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type portionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type portionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type portionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChapterListRelationFilter = {
    every?: chapterWhereInput
    some?: chapterWhereInput
    none?: chapterWhereInput
  }

  export type PortionScalarRelationFilter = {
    is?: portionWhereInput
    isNot?: portionWhereInput
  }

  export type chapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subjectOrderByRelevanceInput = {
    fields: subjectOrderByRelevanceFieldEnum | subjectOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type subjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    portionId?: SortOrder
    createdAt?: SortOrder
  }

  export type subjectAvgOrderByAggregateInput = {
    id?: SortOrder
    portionId?: SortOrder
  }

  export type subjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    portionId?: SortOrder
    createdAt?: SortOrder
  }

  export type subjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    portionId?: SortOrder
    createdAt?: SortOrder
  }

  export type subjectSumOrderByAggregateInput = {
    id?: SortOrder
    portionId?: SortOrder
  }

  export type SubjectScalarRelationFilter = {
    is?: subjectWhereInput
    isNot?: subjectWhereInput
  }

  export type TopicListRelationFilter = {
    every?: topicWhereInput
    some?: topicWhereInput
    none?: topicWhereInput
  }

  export type topicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chapterOrderByRelevanceInput = {
    fields: chapterOrderByRelevanceFieldEnum | chapterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type chapterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
  }

  export type chapterAvgOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
  }

  export type chapterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
  }

  export type chapterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
  }

  export type chapterSumOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
  }

  export type ChapterScalarRelationFilter = {
    is?: chapterWhereInput
    isNot?: chapterWhereInput
  }

  export type topicOrderByRelevanceInput = {
    fields: topicOrderByRelevanceFieldEnum | topicOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type topicCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
  }

  export type topicAvgOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
  }

  export type topicMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
  }

  export type topicMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
  }

  export type topicSumOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
  }

  export type QuestionTypeScalarRelationFilter = {
    is?: questionTypeWhereInput
    isNot?: questionTypeWhereInput
  }

  export type TopicScalarRelationFilter = {
    is?: topicWhereInput
    isNot?: topicWhereInput
  }

  export type questionOrderByRelevanceInput = {
    fields: questionOrderByRelevanceFieldEnum | questionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type questionCountOrderByAggregateInput = {
    id?: SortOrder
    questionTypeId?: SortOrder
    portionId?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    topicId?: SortOrder
    question?: SortOrder
    image?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    hint?: SortOrder
    hintImage?: SortOrder
    createdAt?: SortOrder
  }

  export type questionAvgOrderByAggregateInput = {
    id?: SortOrder
    questionTypeId?: SortOrder
    portionId?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    topicId?: SortOrder
  }

  export type questionMaxOrderByAggregateInput = {
    id?: SortOrder
    questionTypeId?: SortOrder
    portionId?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    topicId?: SortOrder
    question?: SortOrder
    image?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    hint?: SortOrder
    hintImage?: SortOrder
    createdAt?: SortOrder
  }

  export type questionMinOrderByAggregateInput = {
    id?: SortOrder
    questionTypeId?: SortOrder
    portionId?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    topicId?: SortOrder
    question?: SortOrder
    image?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    hint?: SortOrder
    hintImage?: SortOrder
    createdAt?: SortOrder
  }

  export type questionSumOrderByAggregateInput = {
    id?: SortOrder
    questionTypeId?: SortOrder
    portionId?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    topicId?: SortOrder
  }

  export type PortionNullableScalarRelationFilter = {
    is?: portionWhereInput | null
    isNot?: portionWhereInput | null
  }

  export type SubjectNullableScalarRelationFilter = {
    is?: subjectWhereInput | null
    isNot?: subjectWhereInput | null
  }

  export type ChapterNullableScalarRelationFilter = {
    is?: chapterWhereInput | null
    isNot?: chapterWhereInput | null
  }

  export type TopicNullableScalarRelationFilter = {
    is?: topicWhereInput | null
    isNot?: topicWhereInput | null
  }

  export type PdfOrderByRelevanceInput = {
    fields: PdfOrderByRelevanceFieldEnum | PdfOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PdfCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    portionId?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
  }

  export type PdfAvgOrderByAggregateInput = {
    id?: SortOrder
    portionId?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    topicId?: SortOrder
  }

  export type PdfMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    portionId?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
  }

  export type PdfMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    portionId?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
  }

  export type PdfSumOrderByAggregateInput = {
    id?: SortOrder
    portionId?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    topicId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TestResultCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    totalMarks?: SortOrder
    answered?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
    unanswered?: SortOrder
    accuracy?: SortOrder
    totalTimeTaken?: SortOrder
    resultsByType?: SortOrder
    resultsByChapter?: SortOrder
    createdAt?: SortOrder
  }

  export type TestResultAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    totalMarks?: SortOrder
    answered?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
    unanswered?: SortOrder
    accuracy?: SortOrder
    totalTimeTaken?: SortOrder
  }

  export type TestResultMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    totalMarks?: SortOrder
    answered?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
    unanswered?: SortOrder
    accuracy?: SortOrder
    totalTimeTaken?: SortOrder
    createdAt?: SortOrder
  }

  export type TestResultMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    totalMarks?: SortOrder
    answered?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
    unanswered?: SortOrder
    accuracy?: SortOrder
    totalTimeTaken?: SortOrder
    createdAt?: SortOrder
  }

  export type TestResultSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    totalMarks?: SortOrder
    answered?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
    unanswered?: SortOrder
    accuracy?: SortOrder
    totalTimeTaken?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type TestResultCreateNestedManyWithoutUserInput = {
    create?: XOR<TestResultCreateWithoutUserInput, TestResultUncheckedCreateWithoutUserInput> | TestResultCreateWithoutUserInput[] | TestResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestResultCreateOrConnectWithoutUserInput | TestResultCreateOrConnectWithoutUserInput[]
    createMany?: TestResultCreateManyUserInputEnvelope
    connect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
  }

  export type TestResultUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TestResultCreateWithoutUserInput, TestResultUncheckedCreateWithoutUserInput> | TestResultCreateWithoutUserInput[] | TestResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestResultCreateOrConnectWithoutUserInput | TestResultCreateOrConnectWithoutUserInput[]
    createMany?: TestResultCreateManyUserInputEnvelope
    connect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TestResultUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestResultCreateWithoutUserInput, TestResultUncheckedCreateWithoutUserInput> | TestResultCreateWithoutUserInput[] | TestResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestResultCreateOrConnectWithoutUserInput | TestResultCreateOrConnectWithoutUserInput[]
    upsert?: TestResultUpsertWithWhereUniqueWithoutUserInput | TestResultUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestResultCreateManyUserInputEnvelope
    set?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    disconnect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    delete?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    connect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    update?: TestResultUpdateWithWhereUniqueWithoutUserInput | TestResultUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestResultUpdateManyWithWhereWithoutUserInput | TestResultUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestResultScalarWhereInput | TestResultScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TestResultUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestResultCreateWithoutUserInput, TestResultUncheckedCreateWithoutUserInput> | TestResultCreateWithoutUserInput[] | TestResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestResultCreateOrConnectWithoutUserInput | TestResultCreateOrConnectWithoutUserInput[]
    upsert?: TestResultUpsertWithWhereUniqueWithoutUserInput | TestResultUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestResultCreateManyUserInputEnvelope
    set?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    disconnect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    delete?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    connect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    update?: TestResultUpdateWithWhereUniqueWithoutUserInput | TestResultUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestResultUpdateManyWithWhereWithoutUserInput | TestResultUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestResultScalarWhereInput | TestResultScalarWhereInput[]
  }

  export type questionTypeCreateNestedOneWithoutOther_questionTypeInput = {
    create?: XOR<questionTypeCreateWithoutOther_questionTypeInput, questionTypeUncheckedCreateWithoutOther_questionTypeInput>
    connectOrCreate?: questionTypeCreateOrConnectWithoutOther_questionTypeInput
    connect?: questionTypeWhereUniqueInput
  }

  export type questionTypeCreateNestedManyWithoutParentInput = {
    create?: XOR<questionTypeCreateWithoutParentInput, questionTypeUncheckedCreateWithoutParentInput> | questionTypeCreateWithoutParentInput[] | questionTypeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: questionTypeCreateOrConnectWithoutParentInput | questionTypeCreateOrConnectWithoutParentInput[]
    createMany?: questionTypeCreateManyParentInputEnvelope
    connect?: questionTypeWhereUniqueInput | questionTypeWhereUniqueInput[]
  }

  export type questionCreateNestedManyWithoutQuestionTypeInput = {
    create?: XOR<questionCreateWithoutQuestionTypeInput, questionUncheckedCreateWithoutQuestionTypeInput> | questionCreateWithoutQuestionTypeInput[] | questionUncheckedCreateWithoutQuestionTypeInput[]
    connectOrCreate?: questionCreateOrConnectWithoutQuestionTypeInput | questionCreateOrConnectWithoutQuestionTypeInput[]
    createMany?: questionCreateManyQuestionTypeInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type questionTypeUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<questionTypeCreateWithoutParentInput, questionTypeUncheckedCreateWithoutParentInput> | questionTypeCreateWithoutParentInput[] | questionTypeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: questionTypeCreateOrConnectWithoutParentInput | questionTypeCreateOrConnectWithoutParentInput[]
    createMany?: questionTypeCreateManyParentInputEnvelope
    connect?: questionTypeWhereUniqueInput | questionTypeWhereUniqueInput[]
  }

  export type questionUncheckedCreateNestedManyWithoutQuestionTypeInput = {
    create?: XOR<questionCreateWithoutQuestionTypeInput, questionUncheckedCreateWithoutQuestionTypeInput> | questionCreateWithoutQuestionTypeInput[] | questionUncheckedCreateWithoutQuestionTypeInput[]
    connectOrCreate?: questionCreateOrConnectWithoutQuestionTypeInput | questionCreateOrConnectWithoutQuestionTypeInput[]
    createMany?: questionCreateManyQuestionTypeInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type questionTypeUpdateOneWithoutOther_questionTypeNestedInput = {
    create?: XOR<questionTypeCreateWithoutOther_questionTypeInput, questionTypeUncheckedCreateWithoutOther_questionTypeInput>
    connectOrCreate?: questionTypeCreateOrConnectWithoutOther_questionTypeInput
    upsert?: questionTypeUpsertWithoutOther_questionTypeInput
    disconnect?: questionTypeWhereInput | boolean
    delete?: questionTypeWhereInput | boolean
    connect?: questionTypeWhereUniqueInput
    update?: XOR<XOR<questionTypeUpdateToOneWithWhereWithoutOther_questionTypeInput, questionTypeUpdateWithoutOther_questionTypeInput>, questionTypeUncheckedUpdateWithoutOther_questionTypeInput>
  }

  export type questionTypeUpdateManyWithoutParentNestedInput = {
    create?: XOR<questionTypeCreateWithoutParentInput, questionTypeUncheckedCreateWithoutParentInput> | questionTypeCreateWithoutParentInput[] | questionTypeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: questionTypeCreateOrConnectWithoutParentInput | questionTypeCreateOrConnectWithoutParentInput[]
    upsert?: questionTypeUpsertWithWhereUniqueWithoutParentInput | questionTypeUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: questionTypeCreateManyParentInputEnvelope
    set?: questionTypeWhereUniqueInput | questionTypeWhereUniqueInput[]
    disconnect?: questionTypeWhereUniqueInput | questionTypeWhereUniqueInput[]
    delete?: questionTypeWhereUniqueInput | questionTypeWhereUniqueInput[]
    connect?: questionTypeWhereUniqueInput | questionTypeWhereUniqueInput[]
    update?: questionTypeUpdateWithWhereUniqueWithoutParentInput | questionTypeUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: questionTypeUpdateManyWithWhereWithoutParentInput | questionTypeUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: questionTypeScalarWhereInput | questionTypeScalarWhereInput[]
  }

  export type questionUpdateManyWithoutQuestionTypeNestedInput = {
    create?: XOR<questionCreateWithoutQuestionTypeInput, questionUncheckedCreateWithoutQuestionTypeInput> | questionCreateWithoutQuestionTypeInput[] | questionUncheckedCreateWithoutQuestionTypeInput[]
    connectOrCreate?: questionCreateOrConnectWithoutQuestionTypeInput | questionCreateOrConnectWithoutQuestionTypeInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutQuestionTypeInput | questionUpsertWithWhereUniqueWithoutQuestionTypeInput[]
    createMany?: questionCreateManyQuestionTypeInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutQuestionTypeInput | questionUpdateWithWhereUniqueWithoutQuestionTypeInput[]
    updateMany?: questionUpdateManyWithWhereWithoutQuestionTypeInput | questionUpdateManyWithWhereWithoutQuestionTypeInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type questionTypeUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<questionTypeCreateWithoutParentInput, questionTypeUncheckedCreateWithoutParentInput> | questionTypeCreateWithoutParentInput[] | questionTypeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: questionTypeCreateOrConnectWithoutParentInput | questionTypeCreateOrConnectWithoutParentInput[]
    upsert?: questionTypeUpsertWithWhereUniqueWithoutParentInput | questionTypeUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: questionTypeCreateManyParentInputEnvelope
    set?: questionTypeWhereUniqueInput | questionTypeWhereUniqueInput[]
    disconnect?: questionTypeWhereUniqueInput | questionTypeWhereUniqueInput[]
    delete?: questionTypeWhereUniqueInput | questionTypeWhereUniqueInput[]
    connect?: questionTypeWhereUniqueInput | questionTypeWhereUniqueInput[]
    update?: questionTypeUpdateWithWhereUniqueWithoutParentInput | questionTypeUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: questionTypeUpdateManyWithWhereWithoutParentInput | questionTypeUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: questionTypeScalarWhereInput | questionTypeScalarWhereInput[]
  }

  export type questionUncheckedUpdateManyWithoutQuestionTypeNestedInput = {
    create?: XOR<questionCreateWithoutQuestionTypeInput, questionUncheckedCreateWithoutQuestionTypeInput> | questionCreateWithoutQuestionTypeInput[] | questionUncheckedCreateWithoutQuestionTypeInput[]
    connectOrCreate?: questionCreateOrConnectWithoutQuestionTypeInput | questionCreateOrConnectWithoutQuestionTypeInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutQuestionTypeInput | questionUpsertWithWhereUniqueWithoutQuestionTypeInput[]
    createMany?: questionCreateManyQuestionTypeInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutQuestionTypeInput | questionUpdateWithWhereUniqueWithoutQuestionTypeInput[]
    updateMany?: questionUpdateManyWithWhereWithoutQuestionTypeInput | questionUpdateManyWithWhereWithoutQuestionTypeInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type subjectCreateNestedManyWithoutPortionInput = {
    create?: XOR<subjectCreateWithoutPortionInput, subjectUncheckedCreateWithoutPortionInput> | subjectCreateWithoutPortionInput[] | subjectUncheckedCreateWithoutPortionInput[]
    connectOrCreate?: subjectCreateOrConnectWithoutPortionInput | subjectCreateOrConnectWithoutPortionInput[]
    createMany?: subjectCreateManyPortionInputEnvelope
    connect?: subjectWhereUniqueInput | subjectWhereUniqueInput[]
  }

  export type questionCreateNestedManyWithoutPortionInput = {
    create?: XOR<questionCreateWithoutPortionInput, questionUncheckedCreateWithoutPortionInput> | questionCreateWithoutPortionInput[] | questionUncheckedCreateWithoutPortionInput[]
    connectOrCreate?: questionCreateOrConnectWithoutPortionInput | questionCreateOrConnectWithoutPortionInput[]
    createMany?: questionCreateManyPortionInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type PdfCreateNestedManyWithoutPortionInput = {
    create?: XOR<PdfCreateWithoutPortionInput, PdfUncheckedCreateWithoutPortionInput> | PdfCreateWithoutPortionInput[] | PdfUncheckedCreateWithoutPortionInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutPortionInput | PdfCreateOrConnectWithoutPortionInput[]
    createMany?: PdfCreateManyPortionInputEnvelope
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
  }

  export type subjectUncheckedCreateNestedManyWithoutPortionInput = {
    create?: XOR<subjectCreateWithoutPortionInput, subjectUncheckedCreateWithoutPortionInput> | subjectCreateWithoutPortionInput[] | subjectUncheckedCreateWithoutPortionInput[]
    connectOrCreate?: subjectCreateOrConnectWithoutPortionInput | subjectCreateOrConnectWithoutPortionInput[]
    createMany?: subjectCreateManyPortionInputEnvelope
    connect?: subjectWhereUniqueInput | subjectWhereUniqueInput[]
  }

  export type questionUncheckedCreateNestedManyWithoutPortionInput = {
    create?: XOR<questionCreateWithoutPortionInput, questionUncheckedCreateWithoutPortionInput> | questionCreateWithoutPortionInput[] | questionUncheckedCreateWithoutPortionInput[]
    connectOrCreate?: questionCreateOrConnectWithoutPortionInput | questionCreateOrConnectWithoutPortionInput[]
    createMany?: questionCreateManyPortionInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type PdfUncheckedCreateNestedManyWithoutPortionInput = {
    create?: XOR<PdfCreateWithoutPortionInput, PdfUncheckedCreateWithoutPortionInput> | PdfCreateWithoutPortionInput[] | PdfUncheckedCreateWithoutPortionInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutPortionInput | PdfCreateOrConnectWithoutPortionInput[]
    createMany?: PdfCreateManyPortionInputEnvelope
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
  }

  export type subjectUpdateManyWithoutPortionNestedInput = {
    create?: XOR<subjectCreateWithoutPortionInput, subjectUncheckedCreateWithoutPortionInput> | subjectCreateWithoutPortionInput[] | subjectUncheckedCreateWithoutPortionInput[]
    connectOrCreate?: subjectCreateOrConnectWithoutPortionInput | subjectCreateOrConnectWithoutPortionInput[]
    upsert?: subjectUpsertWithWhereUniqueWithoutPortionInput | subjectUpsertWithWhereUniqueWithoutPortionInput[]
    createMany?: subjectCreateManyPortionInputEnvelope
    set?: subjectWhereUniqueInput | subjectWhereUniqueInput[]
    disconnect?: subjectWhereUniqueInput | subjectWhereUniqueInput[]
    delete?: subjectWhereUniqueInput | subjectWhereUniqueInput[]
    connect?: subjectWhereUniqueInput | subjectWhereUniqueInput[]
    update?: subjectUpdateWithWhereUniqueWithoutPortionInput | subjectUpdateWithWhereUniqueWithoutPortionInput[]
    updateMany?: subjectUpdateManyWithWhereWithoutPortionInput | subjectUpdateManyWithWhereWithoutPortionInput[]
    deleteMany?: subjectScalarWhereInput | subjectScalarWhereInput[]
  }

  export type questionUpdateManyWithoutPortionNestedInput = {
    create?: XOR<questionCreateWithoutPortionInput, questionUncheckedCreateWithoutPortionInput> | questionCreateWithoutPortionInput[] | questionUncheckedCreateWithoutPortionInput[]
    connectOrCreate?: questionCreateOrConnectWithoutPortionInput | questionCreateOrConnectWithoutPortionInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutPortionInput | questionUpsertWithWhereUniqueWithoutPortionInput[]
    createMany?: questionCreateManyPortionInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutPortionInput | questionUpdateWithWhereUniqueWithoutPortionInput[]
    updateMany?: questionUpdateManyWithWhereWithoutPortionInput | questionUpdateManyWithWhereWithoutPortionInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type PdfUpdateManyWithoutPortionNestedInput = {
    create?: XOR<PdfCreateWithoutPortionInput, PdfUncheckedCreateWithoutPortionInput> | PdfCreateWithoutPortionInput[] | PdfUncheckedCreateWithoutPortionInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutPortionInput | PdfCreateOrConnectWithoutPortionInput[]
    upsert?: PdfUpsertWithWhereUniqueWithoutPortionInput | PdfUpsertWithWhereUniqueWithoutPortionInput[]
    createMany?: PdfCreateManyPortionInputEnvelope
    set?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    disconnect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    delete?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    update?: PdfUpdateWithWhereUniqueWithoutPortionInput | PdfUpdateWithWhereUniqueWithoutPortionInput[]
    updateMany?: PdfUpdateManyWithWhereWithoutPortionInput | PdfUpdateManyWithWhereWithoutPortionInput[]
    deleteMany?: PdfScalarWhereInput | PdfScalarWhereInput[]
  }

  export type subjectUncheckedUpdateManyWithoutPortionNestedInput = {
    create?: XOR<subjectCreateWithoutPortionInput, subjectUncheckedCreateWithoutPortionInput> | subjectCreateWithoutPortionInput[] | subjectUncheckedCreateWithoutPortionInput[]
    connectOrCreate?: subjectCreateOrConnectWithoutPortionInput | subjectCreateOrConnectWithoutPortionInput[]
    upsert?: subjectUpsertWithWhereUniqueWithoutPortionInput | subjectUpsertWithWhereUniqueWithoutPortionInput[]
    createMany?: subjectCreateManyPortionInputEnvelope
    set?: subjectWhereUniqueInput | subjectWhereUniqueInput[]
    disconnect?: subjectWhereUniqueInput | subjectWhereUniqueInput[]
    delete?: subjectWhereUniqueInput | subjectWhereUniqueInput[]
    connect?: subjectWhereUniqueInput | subjectWhereUniqueInput[]
    update?: subjectUpdateWithWhereUniqueWithoutPortionInput | subjectUpdateWithWhereUniqueWithoutPortionInput[]
    updateMany?: subjectUpdateManyWithWhereWithoutPortionInput | subjectUpdateManyWithWhereWithoutPortionInput[]
    deleteMany?: subjectScalarWhereInput | subjectScalarWhereInput[]
  }

  export type questionUncheckedUpdateManyWithoutPortionNestedInput = {
    create?: XOR<questionCreateWithoutPortionInput, questionUncheckedCreateWithoutPortionInput> | questionCreateWithoutPortionInput[] | questionUncheckedCreateWithoutPortionInput[]
    connectOrCreate?: questionCreateOrConnectWithoutPortionInput | questionCreateOrConnectWithoutPortionInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutPortionInput | questionUpsertWithWhereUniqueWithoutPortionInput[]
    createMany?: questionCreateManyPortionInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutPortionInput | questionUpdateWithWhereUniqueWithoutPortionInput[]
    updateMany?: questionUpdateManyWithWhereWithoutPortionInput | questionUpdateManyWithWhereWithoutPortionInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type PdfUncheckedUpdateManyWithoutPortionNestedInput = {
    create?: XOR<PdfCreateWithoutPortionInput, PdfUncheckedCreateWithoutPortionInput> | PdfCreateWithoutPortionInput[] | PdfUncheckedCreateWithoutPortionInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutPortionInput | PdfCreateOrConnectWithoutPortionInput[]
    upsert?: PdfUpsertWithWhereUniqueWithoutPortionInput | PdfUpsertWithWhereUniqueWithoutPortionInput[]
    createMany?: PdfCreateManyPortionInputEnvelope
    set?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    disconnect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    delete?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    update?: PdfUpdateWithWhereUniqueWithoutPortionInput | PdfUpdateWithWhereUniqueWithoutPortionInput[]
    updateMany?: PdfUpdateManyWithWhereWithoutPortionInput | PdfUpdateManyWithWhereWithoutPortionInput[]
    deleteMany?: PdfScalarWhereInput | PdfScalarWhereInput[]
  }

  export type chapterCreateNestedManyWithoutSubjectInput = {
    create?: XOR<chapterCreateWithoutSubjectInput, chapterUncheckedCreateWithoutSubjectInput> | chapterCreateWithoutSubjectInput[] | chapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: chapterCreateOrConnectWithoutSubjectInput | chapterCreateOrConnectWithoutSubjectInput[]
    createMany?: chapterCreateManySubjectInputEnvelope
    connect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
  }

  export type questionCreateNestedManyWithoutSubjectInput = {
    create?: XOR<questionCreateWithoutSubjectInput, questionUncheckedCreateWithoutSubjectInput> | questionCreateWithoutSubjectInput[] | questionUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: questionCreateOrConnectWithoutSubjectInput | questionCreateOrConnectWithoutSubjectInput[]
    createMany?: questionCreateManySubjectInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type PdfCreateNestedManyWithoutSubjectInput = {
    create?: XOR<PdfCreateWithoutSubjectInput, PdfUncheckedCreateWithoutSubjectInput> | PdfCreateWithoutSubjectInput[] | PdfUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutSubjectInput | PdfCreateOrConnectWithoutSubjectInput[]
    createMany?: PdfCreateManySubjectInputEnvelope
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
  }

  export type portionCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<portionCreateWithoutSubjectsInput, portionUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: portionCreateOrConnectWithoutSubjectsInput
    connect?: portionWhereUniqueInput
  }

  export type chapterUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<chapterCreateWithoutSubjectInput, chapterUncheckedCreateWithoutSubjectInput> | chapterCreateWithoutSubjectInput[] | chapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: chapterCreateOrConnectWithoutSubjectInput | chapterCreateOrConnectWithoutSubjectInput[]
    createMany?: chapterCreateManySubjectInputEnvelope
    connect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
  }

  export type questionUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<questionCreateWithoutSubjectInput, questionUncheckedCreateWithoutSubjectInput> | questionCreateWithoutSubjectInput[] | questionUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: questionCreateOrConnectWithoutSubjectInput | questionCreateOrConnectWithoutSubjectInput[]
    createMany?: questionCreateManySubjectInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type PdfUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<PdfCreateWithoutSubjectInput, PdfUncheckedCreateWithoutSubjectInput> | PdfCreateWithoutSubjectInput[] | PdfUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutSubjectInput | PdfCreateOrConnectWithoutSubjectInput[]
    createMany?: PdfCreateManySubjectInputEnvelope
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
  }

  export type chapterUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<chapterCreateWithoutSubjectInput, chapterUncheckedCreateWithoutSubjectInput> | chapterCreateWithoutSubjectInput[] | chapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: chapterCreateOrConnectWithoutSubjectInput | chapterCreateOrConnectWithoutSubjectInput[]
    upsert?: chapterUpsertWithWhereUniqueWithoutSubjectInput | chapterUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: chapterCreateManySubjectInputEnvelope
    set?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    disconnect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    delete?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    connect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    update?: chapterUpdateWithWhereUniqueWithoutSubjectInput | chapterUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: chapterUpdateManyWithWhereWithoutSubjectInput | chapterUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: chapterScalarWhereInput | chapterScalarWhereInput[]
  }

  export type questionUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<questionCreateWithoutSubjectInput, questionUncheckedCreateWithoutSubjectInput> | questionCreateWithoutSubjectInput[] | questionUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: questionCreateOrConnectWithoutSubjectInput | questionCreateOrConnectWithoutSubjectInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutSubjectInput | questionUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: questionCreateManySubjectInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutSubjectInput | questionUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: questionUpdateManyWithWhereWithoutSubjectInput | questionUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type PdfUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<PdfCreateWithoutSubjectInput, PdfUncheckedCreateWithoutSubjectInput> | PdfCreateWithoutSubjectInput[] | PdfUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutSubjectInput | PdfCreateOrConnectWithoutSubjectInput[]
    upsert?: PdfUpsertWithWhereUniqueWithoutSubjectInput | PdfUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: PdfCreateManySubjectInputEnvelope
    set?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    disconnect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    delete?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    update?: PdfUpdateWithWhereUniqueWithoutSubjectInput | PdfUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: PdfUpdateManyWithWhereWithoutSubjectInput | PdfUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: PdfScalarWhereInput | PdfScalarWhereInput[]
  }

  export type portionUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<portionCreateWithoutSubjectsInput, portionUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: portionCreateOrConnectWithoutSubjectsInput
    upsert?: portionUpsertWithoutSubjectsInput
    connect?: portionWhereUniqueInput
    update?: XOR<XOR<portionUpdateToOneWithWhereWithoutSubjectsInput, portionUpdateWithoutSubjectsInput>, portionUncheckedUpdateWithoutSubjectsInput>
  }

  export type chapterUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<chapterCreateWithoutSubjectInput, chapterUncheckedCreateWithoutSubjectInput> | chapterCreateWithoutSubjectInput[] | chapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: chapterCreateOrConnectWithoutSubjectInput | chapterCreateOrConnectWithoutSubjectInput[]
    upsert?: chapterUpsertWithWhereUniqueWithoutSubjectInput | chapterUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: chapterCreateManySubjectInputEnvelope
    set?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    disconnect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    delete?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    connect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    update?: chapterUpdateWithWhereUniqueWithoutSubjectInput | chapterUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: chapterUpdateManyWithWhereWithoutSubjectInput | chapterUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: chapterScalarWhereInput | chapterScalarWhereInput[]
  }

  export type questionUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<questionCreateWithoutSubjectInput, questionUncheckedCreateWithoutSubjectInput> | questionCreateWithoutSubjectInput[] | questionUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: questionCreateOrConnectWithoutSubjectInput | questionCreateOrConnectWithoutSubjectInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutSubjectInput | questionUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: questionCreateManySubjectInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutSubjectInput | questionUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: questionUpdateManyWithWhereWithoutSubjectInput | questionUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type PdfUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<PdfCreateWithoutSubjectInput, PdfUncheckedCreateWithoutSubjectInput> | PdfCreateWithoutSubjectInput[] | PdfUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutSubjectInput | PdfCreateOrConnectWithoutSubjectInput[]
    upsert?: PdfUpsertWithWhereUniqueWithoutSubjectInput | PdfUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: PdfCreateManySubjectInputEnvelope
    set?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    disconnect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    delete?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    update?: PdfUpdateWithWhereUniqueWithoutSubjectInput | PdfUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: PdfUpdateManyWithWhereWithoutSubjectInput | PdfUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: PdfScalarWhereInput | PdfScalarWhereInput[]
  }

  export type questionCreateNestedManyWithoutChapterInput = {
    create?: XOR<questionCreateWithoutChapterInput, questionUncheckedCreateWithoutChapterInput> | questionCreateWithoutChapterInput[] | questionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: questionCreateOrConnectWithoutChapterInput | questionCreateOrConnectWithoutChapterInput[]
    createMany?: questionCreateManyChapterInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type PdfCreateNestedManyWithoutChapterInput = {
    create?: XOR<PdfCreateWithoutChapterInput, PdfUncheckedCreateWithoutChapterInput> | PdfCreateWithoutChapterInput[] | PdfUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutChapterInput | PdfCreateOrConnectWithoutChapterInput[]
    createMany?: PdfCreateManyChapterInputEnvelope
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
  }

  export type subjectCreateNestedOneWithoutChaptersInput = {
    create?: XOR<subjectCreateWithoutChaptersInput, subjectUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: subjectCreateOrConnectWithoutChaptersInput
    connect?: subjectWhereUniqueInput
  }

  export type topicCreateNestedManyWithoutChapterInput = {
    create?: XOR<topicCreateWithoutChapterInput, topicUncheckedCreateWithoutChapterInput> | topicCreateWithoutChapterInput[] | topicUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: topicCreateOrConnectWithoutChapterInput | topicCreateOrConnectWithoutChapterInput[]
    createMany?: topicCreateManyChapterInputEnvelope
    connect?: topicWhereUniqueInput | topicWhereUniqueInput[]
  }

  export type questionUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<questionCreateWithoutChapterInput, questionUncheckedCreateWithoutChapterInput> | questionCreateWithoutChapterInput[] | questionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: questionCreateOrConnectWithoutChapterInput | questionCreateOrConnectWithoutChapterInput[]
    createMany?: questionCreateManyChapterInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type PdfUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<PdfCreateWithoutChapterInput, PdfUncheckedCreateWithoutChapterInput> | PdfCreateWithoutChapterInput[] | PdfUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutChapterInput | PdfCreateOrConnectWithoutChapterInput[]
    createMany?: PdfCreateManyChapterInputEnvelope
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
  }

  export type topicUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<topicCreateWithoutChapterInput, topicUncheckedCreateWithoutChapterInput> | topicCreateWithoutChapterInput[] | topicUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: topicCreateOrConnectWithoutChapterInput | topicCreateOrConnectWithoutChapterInput[]
    createMany?: topicCreateManyChapterInputEnvelope
    connect?: topicWhereUniqueInput | topicWhereUniqueInput[]
  }

  export type questionUpdateManyWithoutChapterNestedInput = {
    create?: XOR<questionCreateWithoutChapterInput, questionUncheckedCreateWithoutChapterInput> | questionCreateWithoutChapterInput[] | questionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: questionCreateOrConnectWithoutChapterInput | questionCreateOrConnectWithoutChapterInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutChapterInput | questionUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: questionCreateManyChapterInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutChapterInput | questionUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: questionUpdateManyWithWhereWithoutChapterInput | questionUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type PdfUpdateManyWithoutChapterNestedInput = {
    create?: XOR<PdfCreateWithoutChapterInput, PdfUncheckedCreateWithoutChapterInput> | PdfCreateWithoutChapterInput[] | PdfUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutChapterInput | PdfCreateOrConnectWithoutChapterInput[]
    upsert?: PdfUpsertWithWhereUniqueWithoutChapterInput | PdfUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: PdfCreateManyChapterInputEnvelope
    set?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    disconnect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    delete?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    update?: PdfUpdateWithWhereUniqueWithoutChapterInput | PdfUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: PdfUpdateManyWithWhereWithoutChapterInput | PdfUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: PdfScalarWhereInput | PdfScalarWhereInput[]
  }

  export type subjectUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<subjectCreateWithoutChaptersInput, subjectUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: subjectCreateOrConnectWithoutChaptersInput
    upsert?: subjectUpsertWithoutChaptersInput
    connect?: subjectWhereUniqueInput
    update?: XOR<XOR<subjectUpdateToOneWithWhereWithoutChaptersInput, subjectUpdateWithoutChaptersInput>, subjectUncheckedUpdateWithoutChaptersInput>
  }

  export type topicUpdateManyWithoutChapterNestedInput = {
    create?: XOR<topicCreateWithoutChapterInput, topicUncheckedCreateWithoutChapterInput> | topicCreateWithoutChapterInput[] | topicUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: topicCreateOrConnectWithoutChapterInput | topicCreateOrConnectWithoutChapterInput[]
    upsert?: topicUpsertWithWhereUniqueWithoutChapterInput | topicUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: topicCreateManyChapterInputEnvelope
    set?: topicWhereUniqueInput | topicWhereUniqueInput[]
    disconnect?: topicWhereUniqueInput | topicWhereUniqueInput[]
    delete?: topicWhereUniqueInput | topicWhereUniqueInput[]
    connect?: topicWhereUniqueInput | topicWhereUniqueInput[]
    update?: topicUpdateWithWhereUniqueWithoutChapterInput | topicUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: topicUpdateManyWithWhereWithoutChapterInput | topicUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: topicScalarWhereInput | topicScalarWhereInput[]
  }

  export type questionUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<questionCreateWithoutChapterInput, questionUncheckedCreateWithoutChapterInput> | questionCreateWithoutChapterInput[] | questionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: questionCreateOrConnectWithoutChapterInput | questionCreateOrConnectWithoutChapterInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutChapterInput | questionUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: questionCreateManyChapterInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutChapterInput | questionUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: questionUpdateManyWithWhereWithoutChapterInput | questionUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type PdfUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<PdfCreateWithoutChapterInput, PdfUncheckedCreateWithoutChapterInput> | PdfCreateWithoutChapterInput[] | PdfUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutChapterInput | PdfCreateOrConnectWithoutChapterInput[]
    upsert?: PdfUpsertWithWhereUniqueWithoutChapterInput | PdfUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: PdfCreateManyChapterInputEnvelope
    set?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    disconnect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    delete?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    update?: PdfUpdateWithWhereUniqueWithoutChapterInput | PdfUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: PdfUpdateManyWithWhereWithoutChapterInput | PdfUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: PdfScalarWhereInput | PdfScalarWhereInput[]
  }

  export type topicUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<topicCreateWithoutChapterInput, topicUncheckedCreateWithoutChapterInput> | topicCreateWithoutChapterInput[] | topicUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: topicCreateOrConnectWithoutChapterInput | topicCreateOrConnectWithoutChapterInput[]
    upsert?: topicUpsertWithWhereUniqueWithoutChapterInput | topicUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: topicCreateManyChapterInputEnvelope
    set?: topicWhereUniqueInput | topicWhereUniqueInput[]
    disconnect?: topicWhereUniqueInput | topicWhereUniqueInput[]
    delete?: topicWhereUniqueInput | topicWhereUniqueInput[]
    connect?: topicWhereUniqueInput | topicWhereUniqueInput[]
    update?: topicUpdateWithWhereUniqueWithoutChapterInput | topicUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: topicUpdateManyWithWhereWithoutChapterInput | topicUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: topicScalarWhereInput | topicScalarWhereInput[]
  }

  export type questionCreateNestedManyWithoutTopicInput = {
    create?: XOR<questionCreateWithoutTopicInput, questionUncheckedCreateWithoutTopicInput> | questionCreateWithoutTopicInput[] | questionUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: questionCreateOrConnectWithoutTopicInput | questionCreateOrConnectWithoutTopicInput[]
    createMany?: questionCreateManyTopicInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type PdfCreateNestedManyWithoutTopicInput = {
    create?: XOR<PdfCreateWithoutTopicInput, PdfUncheckedCreateWithoutTopicInput> | PdfCreateWithoutTopicInput[] | PdfUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutTopicInput | PdfCreateOrConnectWithoutTopicInput[]
    createMany?: PdfCreateManyTopicInputEnvelope
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
  }

  export type chapterCreateNestedOneWithoutTopicsInput = {
    create?: XOR<chapterCreateWithoutTopicsInput, chapterUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: chapterCreateOrConnectWithoutTopicsInput
    connect?: chapterWhereUniqueInput
  }

  export type questionUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<questionCreateWithoutTopicInput, questionUncheckedCreateWithoutTopicInput> | questionCreateWithoutTopicInput[] | questionUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: questionCreateOrConnectWithoutTopicInput | questionCreateOrConnectWithoutTopicInput[]
    createMany?: questionCreateManyTopicInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type PdfUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<PdfCreateWithoutTopicInput, PdfUncheckedCreateWithoutTopicInput> | PdfCreateWithoutTopicInput[] | PdfUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutTopicInput | PdfCreateOrConnectWithoutTopicInput[]
    createMany?: PdfCreateManyTopicInputEnvelope
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
  }

  export type questionUpdateManyWithoutTopicNestedInput = {
    create?: XOR<questionCreateWithoutTopicInput, questionUncheckedCreateWithoutTopicInput> | questionCreateWithoutTopicInput[] | questionUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: questionCreateOrConnectWithoutTopicInput | questionCreateOrConnectWithoutTopicInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutTopicInput | questionUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: questionCreateManyTopicInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutTopicInput | questionUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: questionUpdateManyWithWhereWithoutTopicInput | questionUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type PdfUpdateManyWithoutTopicNestedInput = {
    create?: XOR<PdfCreateWithoutTopicInput, PdfUncheckedCreateWithoutTopicInput> | PdfCreateWithoutTopicInput[] | PdfUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutTopicInput | PdfCreateOrConnectWithoutTopicInput[]
    upsert?: PdfUpsertWithWhereUniqueWithoutTopicInput | PdfUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: PdfCreateManyTopicInputEnvelope
    set?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    disconnect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    delete?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    update?: PdfUpdateWithWhereUniqueWithoutTopicInput | PdfUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: PdfUpdateManyWithWhereWithoutTopicInput | PdfUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: PdfScalarWhereInput | PdfScalarWhereInput[]
  }

  export type chapterUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<chapterCreateWithoutTopicsInput, chapterUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: chapterCreateOrConnectWithoutTopicsInput
    upsert?: chapterUpsertWithoutTopicsInput
    connect?: chapterWhereUniqueInput
    update?: XOR<XOR<chapterUpdateToOneWithWhereWithoutTopicsInput, chapterUpdateWithoutTopicsInput>, chapterUncheckedUpdateWithoutTopicsInput>
  }

  export type questionUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<questionCreateWithoutTopicInput, questionUncheckedCreateWithoutTopicInput> | questionCreateWithoutTopicInput[] | questionUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: questionCreateOrConnectWithoutTopicInput | questionCreateOrConnectWithoutTopicInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutTopicInput | questionUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: questionCreateManyTopicInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutTopicInput | questionUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: questionUpdateManyWithWhereWithoutTopicInput | questionUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type PdfUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<PdfCreateWithoutTopicInput, PdfUncheckedCreateWithoutTopicInput> | PdfCreateWithoutTopicInput[] | PdfUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: PdfCreateOrConnectWithoutTopicInput | PdfCreateOrConnectWithoutTopicInput[]
    upsert?: PdfUpsertWithWhereUniqueWithoutTopicInput | PdfUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: PdfCreateManyTopicInputEnvelope
    set?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    disconnect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    delete?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    connect?: PdfWhereUniqueInput | PdfWhereUniqueInput[]
    update?: PdfUpdateWithWhereUniqueWithoutTopicInput | PdfUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: PdfUpdateManyWithWhereWithoutTopicInput | PdfUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: PdfScalarWhereInput | PdfScalarWhereInput[]
  }

  export type questionTypeCreateNestedOneWithoutQuestionInput = {
    create?: XOR<questionTypeCreateWithoutQuestionInput, questionTypeUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: questionTypeCreateOrConnectWithoutQuestionInput
    connect?: questionTypeWhereUniqueInput
  }

  export type portionCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<portionCreateWithoutQuestionsInput, portionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: portionCreateOrConnectWithoutQuestionsInput
    connect?: portionWhereUniqueInput
  }

  export type subjectCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<subjectCreateWithoutQuestionsInput, subjectUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: subjectCreateOrConnectWithoutQuestionsInput
    connect?: subjectWhereUniqueInput
  }

  export type chapterCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<chapterCreateWithoutQuestionsInput, chapterUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: chapterCreateOrConnectWithoutQuestionsInput
    connect?: chapterWhereUniqueInput
  }

  export type topicCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<topicCreateWithoutQuestionsInput, topicUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: topicCreateOrConnectWithoutQuestionsInput
    connect?: topicWhereUniqueInput
  }

  export type questionTypeUpdateOneRequiredWithoutQuestionNestedInput = {
    create?: XOR<questionTypeCreateWithoutQuestionInput, questionTypeUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: questionTypeCreateOrConnectWithoutQuestionInput
    upsert?: questionTypeUpsertWithoutQuestionInput
    connect?: questionTypeWhereUniqueInput
    update?: XOR<XOR<questionTypeUpdateToOneWithWhereWithoutQuestionInput, questionTypeUpdateWithoutQuestionInput>, questionTypeUncheckedUpdateWithoutQuestionInput>
  }

  export type portionUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<portionCreateWithoutQuestionsInput, portionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: portionCreateOrConnectWithoutQuestionsInput
    upsert?: portionUpsertWithoutQuestionsInput
    connect?: portionWhereUniqueInput
    update?: XOR<XOR<portionUpdateToOneWithWhereWithoutQuestionsInput, portionUpdateWithoutQuestionsInput>, portionUncheckedUpdateWithoutQuestionsInput>
  }

  export type subjectUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<subjectCreateWithoutQuestionsInput, subjectUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: subjectCreateOrConnectWithoutQuestionsInput
    upsert?: subjectUpsertWithoutQuestionsInput
    connect?: subjectWhereUniqueInput
    update?: XOR<XOR<subjectUpdateToOneWithWhereWithoutQuestionsInput, subjectUpdateWithoutQuestionsInput>, subjectUncheckedUpdateWithoutQuestionsInput>
  }

  export type chapterUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<chapterCreateWithoutQuestionsInput, chapterUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: chapterCreateOrConnectWithoutQuestionsInput
    upsert?: chapterUpsertWithoutQuestionsInput
    connect?: chapterWhereUniqueInput
    update?: XOR<XOR<chapterUpdateToOneWithWhereWithoutQuestionsInput, chapterUpdateWithoutQuestionsInput>, chapterUncheckedUpdateWithoutQuestionsInput>
  }

  export type topicUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<topicCreateWithoutQuestionsInput, topicUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: topicCreateOrConnectWithoutQuestionsInput
    upsert?: topicUpsertWithoutQuestionsInput
    connect?: topicWhereUniqueInput
    update?: XOR<XOR<topicUpdateToOneWithWhereWithoutQuestionsInput, topicUpdateWithoutQuestionsInput>, topicUncheckedUpdateWithoutQuestionsInput>
  }

  export type portionCreateNestedOneWithoutPdfsInput = {
    create?: XOR<portionCreateWithoutPdfsInput, portionUncheckedCreateWithoutPdfsInput>
    connectOrCreate?: portionCreateOrConnectWithoutPdfsInput
    connect?: portionWhereUniqueInput
  }

  export type subjectCreateNestedOneWithoutPdfsInput = {
    create?: XOR<subjectCreateWithoutPdfsInput, subjectUncheckedCreateWithoutPdfsInput>
    connectOrCreate?: subjectCreateOrConnectWithoutPdfsInput
    connect?: subjectWhereUniqueInput
  }

  export type chapterCreateNestedOneWithoutPdfsInput = {
    create?: XOR<chapterCreateWithoutPdfsInput, chapterUncheckedCreateWithoutPdfsInput>
    connectOrCreate?: chapterCreateOrConnectWithoutPdfsInput
    connect?: chapterWhereUniqueInput
  }

  export type topicCreateNestedOneWithoutPdfsInput = {
    create?: XOR<topicCreateWithoutPdfsInput, topicUncheckedCreateWithoutPdfsInput>
    connectOrCreate?: topicCreateOrConnectWithoutPdfsInput
    connect?: topicWhereUniqueInput
  }

  export type portionUpdateOneWithoutPdfsNestedInput = {
    create?: XOR<portionCreateWithoutPdfsInput, portionUncheckedCreateWithoutPdfsInput>
    connectOrCreate?: portionCreateOrConnectWithoutPdfsInput
    upsert?: portionUpsertWithoutPdfsInput
    disconnect?: portionWhereInput | boolean
    delete?: portionWhereInput | boolean
    connect?: portionWhereUniqueInput
    update?: XOR<XOR<portionUpdateToOneWithWhereWithoutPdfsInput, portionUpdateWithoutPdfsInput>, portionUncheckedUpdateWithoutPdfsInput>
  }

  export type subjectUpdateOneWithoutPdfsNestedInput = {
    create?: XOR<subjectCreateWithoutPdfsInput, subjectUncheckedCreateWithoutPdfsInput>
    connectOrCreate?: subjectCreateOrConnectWithoutPdfsInput
    upsert?: subjectUpsertWithoutPdfsInput
    disconnect?: subjectWhereInput | boolean
    delete?: subjectWhereInput | boolean
    connect?: subjectWhereUniqueInput
    update?: XOR<XOR<subjectUpdateToOneWithWhereWithoutPdfsInput, subjectUpdateWithoutPdfsInput>, subjectUncheckedUpdateWithoutPdfsInput>
  }

  export type chapterUpdateOneWithoutPdfsNestedInput = {
    create?: XOR<chapterCreateWithoutPdfsInput, chapterUncheckedCreateWithoutPdfsInput>
    connectOrCreate?: chapterCreateOrConnectWithoutPdfsInput
    upsert?: chapterUpsertWithoutPdfsInput
    disconnect?: chapterWhereInput | boolean
    delete?: chapterWhereInput | boolean
    connect?: chapterWhereUniqueInput
    update?: XOR<XOR<chapterUpdateToOneWithWhereWithoutPdfsInput, chapterUpdateWithoutPdfsInput>, chapterUncheckedUpdateWithoutPdfsInput>
  }

  export type topicUpdateOneWithoutPdfsNestedInput = {
    create?: XOR<topicCreateWithoutPdfsInput, topicUncheckedCreateWithoutPdfsInput>
    connectOrCreate?: topicCreateOrConnectWithoutPdfsInput
    upsert?: topicUpsertWithoutPdfsInput
    disconnect?: topicWhereInput | boolean
    delete?: topicWhereInput | boolean
    connect?: topicWhereUniqueInput
    update?: XOR<XOR<topicUpdateToOneWithWhereWithoutPdfsInput, topicUpdateWithoutPdfsInput>, topicUncheckedUpdateWithoutPdfsInput>
  }

  export type UserCreateNestedOneWithoutTestResultsInput = {
    create?: XOR<UserCreateWithoutTestResultsInput, UserUncheckedCreateWithoutTestResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestResultsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutTestResultsNestedInput = {
    create?: XOR<UserCreateWithoutTestResultsInput, UserUncheckedCreateWithoutTestResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestResultsInput
    upsert?: UserUpsertWithoutTestResultsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestResultsInput, UserUpdateWithoutTestResultsInput>, UserUncheckedUpdateWithoutTestResultsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TestResultCreateWithoutUserInput = {
    score: number
    totalMarks: number
    answered: number
    correct: number
    wrong: number
    unanswered: number
    accuracy: number
    totalTimeTaken: number
    resultsByType: JsonNullValueInput | InputJsonValue
    resultsByChapter: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TestResultUncheckedCreateWithoutUserInput = {
    id?: number
    score: number
    totalMarks: number
    answered: number
    correct: number
    wrong: number
    unanswered: number
    accuracy: number
    totalTimeTaken: number
    resultsByType: JsonNullValueInput | InputJsonValue
    resultsByChapter: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TestResultCreateOrConnectWithoutUserInput = {
    where: TestResultWhereUniqueInput
    create: XOR<TestResultCreateWithoutUserInput, TestResultUncheckedCreateWithoutUserInput>
  }

  export type TestResultCreateManyUserInputEnvelope = {
    data: TestResultCreateManyUserInput | TestResultCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TestResultUpsertWithWhereUniqueWithoutUserInput = {
    where: TestResultWhereUniqueInput
    update: XOR<TestResultUpdateWithoutUserInput, TestResultUncheckedUpdateWithoutUserInput>
    create: XOR<TestResultCreateWithoutUserInput, TestResultUncheckedCreateWithoutUserInput>
  }

  export type TestResultUpdateWithWhereUniqueWithoutUserInput = {
    where: TestResultWhereUniqueInput
    data: XOR<TestResultUpdateWithoutUserInput, TestResultUncheckedUpdateWithoutUserInput>
  }

  export type TestResultUpdateManyWithWhereWithoutUserInput = {
    where: TestResultScalarWhereInput
    data: XOR<TestResultUpdateManyMutationInput, TestResultUncheckedUpdateManyWithoutUserInput>
  }

  export type TestResultScalarWhereInput = {
    AND?: TestResultScalarWhereInput | TestResultScalarWhereInput[]
    OR?: TestResultScalarWhereInput[]
    NOT?: TestResultScalarWhereInput | TestResultScalarWhereInput[]
    id?: IntFilter<"TestResult"> | number
    userId?: IntFilter<"TestResult"> | number
    score?: IntFilter<"TestResult"> | number
    totalMarks?: IntFilter<"TestResult"> | number
    answered?: IntFilter<"TestResult"> | number
    correct?: IntFilter<"TestResult"> | number
    wrong?: IntFilter<"TestResult"> | number
    unanswered?: IntFilter<"TestResult"> | number
    accuracy?: FloatFilter<"TestResult"> | number
    totalTimeTaken?: IntFilter<"TestResult"> | number
    resultsByType?: JsonFilter<"TestResult">
    resultsByChapter?: JsonFilter<"TestResult">
    createdAt?: DateTimeFilter<"TestResult"> | Date | string
  }

  export type questionTypeCreateWithoutOther_questionTypeInput = {
    name: string
    createdAt?: Date | string
    parent?: questionTypeCreateNestedOneWithoutOther_questionTypeInput
    question?: questionCreateNestedManyWithoutQuestionTypeInput
  }

  export type questionTypeUncheckedCreateWithoutOther_questionTypeInput = {
    id?: number
    name: string
    parentId?: number | null
    createdAt?: Date | string
    question?: questionUncheckedCreateNestedManyWithoutQuestionTypeInput
  }

  export type questionTypeCreateOrConnectWithoutOther_questionTypeInput = {
    where: questionTypeWhereUniqueInput
    create: XOR<questionTypeCreateWithoutOther_questionTypeInput, questionTypeUncheckedCreateWithoutOther_questionTypeInput>
  }

  export type questionTypeCreateWithoutParentInput = {
    name: string
    createdAt?: Date | string
    other_questionType?: questionTypeCreateNestedManyWithoutParentInput
    question?: questionCreateNestedManyWithoutQuestionTypeInput
  }

  export type questionTypeUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    createdAt?: Date | string
    other_questionType?: questionTypeUncheckedCreateNestedManyWithoutParentInput
    question?: questionUncheckedCreateNestedManyWithoutQuestionTypeInput
  }

  export type questionTypeCreateOrConnectWithoutParentInput = {
    where: questionTypeWhereUniqueInput
    create: XOR<questionTypeCreateWithoutParentInput, questionTypeUncheckedCreateWithoutParentInput>
  }

  export type questionTypeCreateManyParentInputEnvelope = {
    data: questionTypeCreateManyParentInput | questionTypeCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type questionCreateWithoutQuestionTypeInput = {
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
    portion: portionCreateNestedOneWithoutQuestionsInput
    subject: subjectCreateNestedOneWithoutQuestionsInput
    chapter: chapterCreateNestedOneWithoutQuestionsInput
    topic: topicCreateNestedOneWithoutQuestionsInput
  }

  export type questionUncheckedCreateWithoutQuestionTypeInput = {
    id?: number
    portionId: number
    subjectId: number
    chapterId: number
    topicId: number
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
  }

  export type questionCreateOrConnectWithoutQuestionTypeInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutQuestionTypeInput, questionUncheckedCreateWithoutQuestionTypeInput>
  }

  export type questionCreateManyQuestionTypeInputEnvelope = {
    data: questionCreateManyQuestionTypeInput | questionCreateManyQuestionTypeInput[]
    skipDuplicates?: boolean
  }

  export type questionTypeUpsertWithoutOther_questionTypeInput = {
    update: XOR<questionTypeUpdateWithoutOther_questionTypeInput, questionTypeUncheckedUpdateWithoutOther_questionTypeInput>
    create: XOR<questionTypeCreateWithoutOther_questionTypeInput, questionTypeUncheckedCreateWithoutOther_questionTypeInput>
    where?: questionTypeWhereInput
  }

  export type questionTypeUpdateToOneWithWhereWithoutOther_questionTypeInput = {
    where?: questionTypeWhereInput
    data: XOR<questionTypeUpdateWithoutOther_questionTypeInput, questionTypeUncheckedUpdateWithoutOther_questionTypeInput>
  }

  export type questionTypeUpdateWithoutOther_questionTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: questionTypeUpdateOneWithoutOther_questionTypeNestedInput
    question?: questionUpdateManyWithoutQuestionTypeNestedInput
  }

  export type questionTypeUncheckedUpdateWithoutOther_questionTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: questionUncheckedUpdateManyWithoutQuestionTypeNestedInput
  }

  export type questionTypeUpsertWithWhereUniqueWithoutParentInput = {
    where: questionTypeWhereUniqueInput
    update: XOR<questionTypeUpdateWithoutParentInput, questionTypeUncheckedUpdateWithoutParentInput>
    create: XOR<questionTypeCreateWithoutParentInput, questionTypeUncheckedCreateWithoutParentInput>
  }

  export type questionTypeUpdateWithWhereUniqueWithoutParentInput = {
    where: questionTypeWhereUniqueInput
    data: XOR<questionTypeUpdateWithoutParentInput, questionTypeUncheckedUpdateWithoutParentInput>
  }

  export type questionTypeUpdateManyWithWhereWithoutParentInput = {
    where: questionTypeScalarWhereInput
    data: XOR<questionTypeUpdateManyMutationInput, questionTypeUncheckedUpdateManyWithoutParentInput>
  }

  export type questionTypeScalarWhereInput = {
    AND?: questionTypeScalarWhereInput | questionTypeScalarWhereInput[]
    OR?: questionTypeScalarWhereInput[]
    NOT?: questionTypeScalarWhereInput | questionTypeScalarWhereInput[]
    id?: IntFilter<"questionType"> | number
    name?: StringFilter<"questionType"> | string
    parentId?: IntNullableFilter<"questionType"> | number | null
    createdAt?: DateTimeFilter<"questionType"> | Date | string
  }

  export type questionUpsertWithWhereUniqueWithoutQuestionTypeInput = {
    where: questionWhereUniqueInput
    update: XOR<questionUpdateWithoutQuestionTypeInput, questionUncheckedUpdateWithoutQuestionTypeInput>
    create: XOR<questionCreateWithoutQuestionTypeInput, questionUncheckedCreateWithoutQuestionTypeInput>
  }

  export type questionUpdateWithWhereUniqueWithoutQuestionTypeInput = {
    where: questionWhereUniqueInput
    data: XOR<questionUpdateWithoutQuestionTypeInput, questionUncheckedUpdateWithoutQuestionTypeInput>
  }

  export type questionUpdateManyWithWhereWithoutQuestionTypeInput = {
    where: questionScalarWhereInput
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyWithoutQuestionTypeInput>
  }

  export type questionScalarWhereInput = {
    AND?: questionScalarWhereInput | questionScalarWhereInput[]
    OR?: questionScalarWhereInput[]
    NOT?: questionScalarWhereInput | questionScalarWhereInput[]
    id?: IntFilter<"question"> | number
    questionTypeId?: IntFilter<"question"> | number
    portionId?: IntFilter<"question"> | number
    subjectId?: IntFilter<"question"> | number
    chapterId?: IntFilter<"question"> | number
    topicId?: IntFilter<"question"> | number
    question?: StringFilter<"question"> | string
    image?: StringNullableFilter<"question"> | string | null
    optionA?: StringFilter<"question"> | string
    optionB?: StringFilter<"question"> | string
    optionC?: StringFilter<"question"> | string
    optionD?: StringFilter<"question"> | string
    correctOption?: StringFilter<"question"> | string
    hint?: StringNullableFilter<"question"> | string | null
    hintImage?: StringNullableFilter<"question"> | string | null
    createdAt?: DateTimeFilter<"question"> | Date | string
  }

  export type subjectCreateWithoutPortionInput = {
    name: string
    createdAt?: Date | string
    chapters?: chapterCreateNestedManyWithoutSubjectInput
    questions?: questionCreateNestedManyWithoutSubjectInput
    pdfs?: PdfCreateNestedManyWithoutSubjectInput
  }

  export type subjectUncheckedCreateWithoutPortionInput = {
    id?: number
    name: string
    createdAt?: Date | string
    chapters?: chapterUncheckedCreateNestedManyWithoutSubjectInput
    questions?: questionUncheckedCreateNestedManyWithoutSubjectInput
    pdfs?: PdfUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectCreateOrConnectWithoutPortionInput = {
    where: subjectWhereUniqueInput
    create: XOR<subjectCreateWithoutPortionInput, subjectUncheckedCreateWithoutPortionInput>
  }

  export type subjectCreateManyPortionInputEnvelope = {
    data: subjectCreateManyPortionInput | subjectCreateManyPortionInput[]
    skipDuplicates?: boolean
  }

  export type questionCreateWithoutPortionInput = {
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
    questionType: questionTypeCreateNestedOneWithoutQuestionInput
    subject: subjectCreateNestedOneWithoutQuestionsInput
    chapter: chapterCreateNestedOneWithoutQuestionsInput
    topic: topicCreateNestedOneWithoutQuestionsInput
  }

  export type questionUncheckedCreateWithoutPortionInput = {
    id?: number
    questionTypeId: number
    subjectId: number
    chapterId: number
    topicId: number
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
  }

  export type questionCreateOrConnectWithoutPortionInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutPortionInput, questionUncheckedCreateWithoutPortionInput>
  }

  export type questionCreateManyPortionInputEnvelope = {
    data: questionCreateManyPortionInput | questionCreateManyPortionInput[]
    skipDuplicates?: boolean
  }

  export type PdfCreateWithoutPortionInput = {
    name: string
    url: string
    createdAt?: Date | string
    subject?: subjectCreateNestedOneWithoutPdfsInput
    chapter?: chapterCreateNestedOneWithoutPdfsInput
    topic?: topicCreateNestedOneWithoutPdfsInput
  }

  export type PdfUncheckedCreateWithoutPortionInput = {
    id?: number
    name: string
    url: string
    subjectId?: number | null
    chapterId?: number | null
    topicId?: number | null
    createdAt?: Date | string
  }

  export type PdfCreateOrConnectWithoutPortionInput = {
    where: PdfWhereUniqueInput
    create: XOR<PdfCreateWithoutPortionInput, PdfUncheckedCreateWithoutPortionInput>
  }

  export type PdfCreateManyPortionInputEnvelope = {
    data: PdfCreateManyPortionInput | PdfCreateManyPortionInput[]
    skipDuplicates?: boolean
  }

  export type subjectUpsertWithWhereUniqueWithoutPortionInput = {
    where: subjectWhereUniqueInput
    update: XOR<subjectUpdateWithoutPortionInput, subjectUncheckedUpdateWithoutPortionInput>
    create: XOR<subjectCreateWithoutPortionInput, subjectUncheckedCreateWithoutPortionInput>
  }

  export type subjectUpdateWithWhereUniqueWithoutPortionInput = {
    where: subjectWhereUniqueInput
    data: XOR<subjectUpdateWithoutPortionInput, subjectUncheckedUpdateWithoutPortionInput>
  }

  export type subjectUpdateManyWithWhereWithoutPortionInput = {
    where: subjectScalarWhereInput
    data: XOR<subjectUpdateManyMutationInput, subjectUncheckedUpdateManyWithoutPortionInput>
  }

  export type subjectScalarWhereInput = {
    AND?: subjectScalarWhereInput | subjectScalarWhereInput[]
    OR?: subjectScalarWhereInput[]
    NOT?: subjectScalarWhereInput | subjectScalarWhereInput[]
    id?: IntFilter<"subject"> | number
    name?: StringFilter<"subject"> | string
    portionId?: IntFilter<"subject"> | number
    createdAt?: DateTimeFilter<"subject"> | Date | string
  }

  export type questionUpsertWithWhereUniqueWithoutPortionInput = {
    where: questionWhereUniqueInput
    update: XOR<questionUpdateWithoutPortionInput, questionUncheckedUpdateWithoutPortionInput>
    create: XOR<questionCreateWithoutPortionInput, questionUncheckedCreateWithoutPortionInput>
  }

  export type questionUpdateWithWhereUniqueWithoutPortionInput = {
    where: questionWhereUniqueInput
    data: XOR<questionUpdateWithoutPortionInput, questionUncheckedUpdateWithoutPortionInput>
  }

  export type questionUpdateManyWithWhereWithoutPortionInput = {
    where: questionScalarWhereInput
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyWithoutPortionInput>
  }

  export type PdfUpsertWithWhereUniqueWithoutPortionInput = {
    where: PdfWhereUniqueInput
    update: XOR<PdfUpdateWithoutPortionInput, PdfUncheckedUpdateWithoutPortionInput>
    create: XOR<PdfCreateWithoutPortionInput, PdfUncheckedCreateWithoutPortionInput>
  }

  export type PdfUpdateWithWhereUniqueWithoutPortionInput = {
    where: PdfWhereUniqueInput
    data: XOR<PdfUpdateWithoutPortionInput, PdfUncheckedUpdateWithoutPortionInput>
  }

  export type PdfUpdateManyWithWhereWithoutPortionInput = {
    where: PdfScalarWhereInput
    data: XOR<PdfUpdateManyMutationInput, PdfUncheckedUpdateManyWithoutPortionInput>
  }

  export type PdfScalarWhereInput = {
    AND?: PdfScalarWhereInput | PdfScalarWhereInput[]
    OR?: PdfScalarWhereInput[]
    NOT?: PdfScalarWhereInput | PdfScalarWhereInput[]
    id?: IntFilter<"Pdf"> | number
    name?: StringFilter<"Pdf"> | string
    url?: StringFilter<"Pdf"> | string
    portionId?: IntNullableFilter<"Pdf"> | number | null
    subjectId?: IntNullableFilter<"Pdf"> | number | null
    chapterId?: IntNullableFilter<"Pdf"> | number | null
    topicId?: IntNullableFilter<"Pdf"> | number | null
    createdAt?: DateTimeFilter<"Pdf"> | Date | string
  }

  export type chapterCreateWithoutSubjectInput = {
    name: string
    createdAt?: Date | string
    questions?: questionCreateNestedManyWithoutChapterInput
    pdfs?: PdfCreateNestedManyWithoutChapterInput
    topics?: topicCreateNestedManyWithoutChapterInput
  }

  export type chapterUncheckedCreateWithoutSubjectInput = {
    id?: number
    name: string
    createdAt?: Date | string
    questions?: questionUncheckedCreateNestedManyWithoutChapterInput
    pdfs?: PdfUncheckedCreateNestedManyWithoutChapterInput
    topics?: topicUncheckedCreateNestedManyWithoutChapterInput
  }

  export type chapterCreateOrConnectWithoutSubjectInput = {
    where: chapterWhereUniqueInput
    create: XOR<chapterCreateWithoutSubjectInput, chapterUncheckedCreateWithoutSubjectInput>
  }

  export type chapterCreateManySubjectInputEnvelope = {
    data: chapterCreateManySubjectInput | chapterCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type questionCreateWithoutSubjectInput = {
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
    questionType: questionTypeCreateNestedOneWithoutQuestionInput
    portion: portionCreateNestedOneWithoutQuestionsInput
    chapter: chapterCreateNestedOneWithoutQuestionsInput
    topic: topicCreateNestedOneWithoutQuestionsInput
  }

  export type questionUncheckedCreateWithoutSubjectInput = {
    id?: number
    questionTypeId: number
    portionId: number
    chapterId: number
    topicId: number
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
  }

  export type questionCreateOrConnectWithoutSubjectInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutSubjectInput, questionUncheckedCreateWithoutSubjectInput>
  }

  export type questionCreateManySubjectInputEnvelope = {
    data: questionCreateManySubjectInput | questionCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type PdfCreateWithoutSubjectInput = {
    name: string
    url: string
    createdAt?: Date | string
    portion?: portionCreateNestedOneWithoutPdfsInput
    chapter?: chapterCreateNestedOneWithoutPdfsInput
    topic?: topicCreateNestedOneWithoutPdfsInput
  }

  export type PdfUncheckedCreateWithoutSubjectInput = {
    id?: number
    name: string
    url: string
    portionId?: number | null
    chapterId?: number | null
    topicId?: number | null
    createdAt?: Date | string
  }

  export type PdfCreateOrConnectWithoutSubjectInput = {
    where: PdfWhereUniqueInput
    create: XOR<PdfCreateWithoutSubjectInput, PdfUncheckedCreateWithoutSubjectInput>
  }

  export type PdfCreateManySubjectInputEnvelope = {
    data: PdfCreateManySubjectInput | PdfCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type portionCreateWithoutSubjectsInput = {
    name: string
    createdAt?: Date | string
    questions?: questionCreateNestedManyWithoutPortionInput
    pdfs?: PdfCreateNestedManyWithoutPortionInput
  }

  export type portionUncheckedCreateWithoutSubjectsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    questions?: questionUncheckedCreateNestedManyWithoutPortionInput
    pdfs?: PdfUncheckedCreateNestedManyWithoutPortionInput
  }

  export type portionCreateOrConnectWithoutSubjectsInput = {
    where: portionWhereUniqueInput
    create: XOR<portionCreateWithoutSubjectsInput, portionUncheckedCreateWithoutSubjectsInput>
  }

  export type chapterUpsertWithWhereUniqueWithoutSubjectInput = {
    where: chapterWhereUniqueInput
    update: XOR<chapterUpdateWithoutSubjectInput, chapterUncheckedUpdateWithoutSubjectInput>
    create: XOR<chapterCreateWithoutSubjectInput, chapterUncheckedCreateWithoutSubjectInput>
  }

  export type chapterUpdateWithWhereUniqueWithoutSubjectInput = {
    where: chapterWhereUniqueInput
    data: XOR<chapterUpdateWithoutSubjectInput, chapterUncheckedUpdateWithoutSubjectInput>
  }

  export type chapterUpdateManyWithWhereWithoutSubjectInput = {
    where: chapterScalarWhereInput
    data: XOR<chapterUpdateManyMutationInput, chapterUncheckedUpdateManyWithoutSubjectInput>
  }

  export type chapterScalarWhereInput = {
    AND?: chapterScalarWhereInput | chapterScalarWhereInput[]
    OR?: chapterScalarWhereInput[]
    NOT?: chapterScalarWhereInput | chapterScalarWhereInput[]
    id?: IntFilter<"chapter"> | number
    name?: StringFilter<"chapter"> | string
    subjectId?: IntFilter<"chapter"> | number
    createdAt?: DateTimeFilter<"chapter"> | Date | string
  }

  export type questionUpsertWithWhereUniqueWithoutSubjectInput = {
    where: questionWhereUniqueInput
    update: XOR<questionUpdateWithoutSubjectInput, questionUncheckedUpdateWithoutSubjectInput>
    create: XOR<questionCreateWithoutSubjectInput, questionUncheckedCreateWithoutSubjectInput>
  }

  export type questionUpdateWithWhereUniqueWithoutSubjectInput = {
    where: questionWhereUniqueInput
    data: XOR<questionUpdateWithoutSubjectInput, questionUncheckedUpdateWithoutSubjectInput>
  }

  export type questionUpdateManyWithWhereWithoutSubjectInput = {
    where: questionScalarWhereInput
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyWithoutSubjectInput>
  }

  export type PdfUpsertWithWhereUniqueWithoutSubjectInput = {
    where: PdfWhereUniqueInput
    update: XOR<PdfUpdateWithoutSubjectInput, PdfUncheckedUpdateWithoutSubjectInput>
    create: XOR<PdfCreateWithoutSubjectInput, PdfUncheckedCreateWithoutSubjectInput>
  }

  export type PdfUpdateWithWhereUniqueWithoutSubjectInput = {
    where: PdfWhereUniqueInput
    data: XOR<PdfUpdateWithoutSubjectInput, PdfUncheckedUpdateWithoutSubjectInput>
  }

  export type PdfUpdateManyWithWhereWithoutSubjectInput = {
    where: PdfScalarWhereInput
    data: XOR<PdfUpdateManyMutationInput, PdfUncheckedUpdateManyWithoutSubjectInput>
  }

  export type portionUpsertWithoutSubjectsInput = {
    update: XOR<portionUpdateWithoutSubjectsInput, portionUncheckedUpdateWithoutSubjectsInput>
    create: XOR<portionCreateWithoutSubjectsInput, portionUncheckedCreateWithoutSubjectsInput>
    where?: portionWhereInput
  }

  export type portionUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: portionWhereInput
    data: XOR<portionUpdateWithoutSubjectsInput, portionUncheckedUpdateWithoutSubjectsInput>
  }

  export type portionUpdateWithoutSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUpdateManyWithoutPortionNestedInput
    pdfs?: PdfUpdateManyWithoutPortionNestedInput
  }

  export type portionUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUncheckedUpdateManyWithoutPortionNestedInput
    pdfs?: PdfUncheckedUpdateManyWithoutPortionNestedInput
  }

  export type questionCreateWithoutChapterInput = {
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
    questionType: questionTypeCreateNestedOneWithoutQuestionInput
    portion: portionCreateNestedOneWithoutQuestionsInput
    subject: subjectCreateNestedOneWithoutQuestionsInput
    topic: topicCreateNestedOneWithoutQuestionsInput
  }

  export type questionUncheckedCreateWithoutChapterInput = {
    id?: number
    questionTypeId: number
    portionId: number
    subjectId: number
    topicId: number
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
  }

  export type questionCreateOrConnectWithoutChapterInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutChapterInput, questionUncheckedCreateWithoutChapterInput>
  }

  export type questionCreateManyChapterInputEnvelope = {
    data: questionCreateManyChapterInput | questionCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type PdfCreateWithoutChapterInput = {
    name: string
    url: string
    createdAt?: Date | string
    portion?: portionCreateNestedOneWithoutPdfsInput
    subject?: subjectCreateNestedOneWithoutPdfsInput
    topic?: topicCreateNestedOneWithoutPdfsInput
  }

  export type PdfUncheckedCreateWithoutChapterInput = {
    id?: number
    name: string
    url: string
    portionId?: number | null
    subjectId?: number | null
    topicId?: number | null
    createdAt?: Date | string
  }

  export type PdfCreateOrConnectWithoutChapterInput = {
    where: PdfWhereUniqueInput
    create: XOR<PdfCreateWithoutChapterInput, PdfUncheckedCreateWithoutChapterInput>
  }

  export type PdfCreateManyChapterInputEnvelope = {
    data: PdfCreateManyChapterInput | PdfCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type subjectCreateWithoutChaptersInput = {
    name: string
    createdAt?: Date | string
    questions?: questionCreateNestedManyWithoutSubjectInput
    pdfs?: PdfCreateNestedManyWithoutSubjectInput
    portion: portionCreateNestedOneWithoutSubjectsInput
  }

  export type subjectUncheckedCreateWithoutChaptersInput = {
    id?: number
    name: string
    portionId: number
    createdAt?: Date | string
    questions?: questionUncheckedCreateNestedManyWithoutSubjectInput
    pdfs?: PdfUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectCreateOrConnectWithoutChaptersInput = {
    where: subjectWhereUniqueInput
    create: XOR<subjectCreateWithoutChaptersInput, subjectUncheckedCreateWithoutChaptersInput>
  }

  export type topicCreateWithoutChapterInput = {
    name: string
    createdAt?: Date | string
    questions?: questionCreateNestedManyWithoutTopicInput
    pdfs?: PdfCreateNestedManyWithoutTopicInput
  }

  export type topicUncheckedCreateWithoutChapterInput = {
    id?: number
    name: string
    createdAt?: Date | string
    questions?: questionUncheckedCreateNestedManyWithoutTopicInput
    pdfs?: PdfUncheckedCreateNestedManyWithoutTopicInput
  }

  export type topicCreateOrConnectWithoutChapterInput = {
    where: topicWhereUniqueInput
    create: XOR<topicCreateWithoutChapterInput, topicUncheckedCreateWithoutChapterInput>
  }

  export type topicCreateManyChapterInputEnvelope = {
    data: topicCreateManyChapterInput | topicCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type questionUpsertWithWhereUniqueWithoutChapterInput = {
    where: questionWhereUniqueInput
    update: XOR<questionUpdateWithoutChapterInput, questionUncheckedUpdateWithoutChapterInput>
    create: XOR<questionCreateWithoutChapterInput, questionUncheckedCreateWithoutChapterInput>
  }

  export type questionUpdateWithWhereUniqueWithoutChapterInput = {
    where: questionWhereUniqueInput
    data: XOR<questionUpdateWithoutChapterInput, questionUncheckedUpdateWithoutChapterInput>
  }

  export type questionUpdateManyWithWhereWithoutChapterInput = {
    where: questionScalarWhereInput
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyWithoutChapterInput>
  }

  export type PdfUpsertWithWhereUniqueWithoutChapterInput = {
    where: PdfWhereUniqueInput
    update: XOR<PdfUpdateWithoutChapterInput, PdfUncheckedUpdateWithoutChapterInput>
    create: XOR<PdfCreateWithoutChapterInput, PdfUncheckedCreateWithoutChapterInput>
  }

  export type PdfUpdateWithWhereUniqueWithoutChapterInput = {
    where: PdfWhereUniqueInput
    data: XOR<PdfUpdateWithoutChapterInput, PdfUncheckedUpdateWithoutChapterInput>
  }

  export type PdfUpdateManyWithWhereWithoutChapterInput = {
    where: PdfScalarWhereInput
    data: XOR<PdfUpdateManyMutationInput, PdfUncheckedUpdateManyWithoutChapterInput>
  }

  export type subjectUpsertWithoutChaptersInput = {
    update: XOR<subjectUpdateWithoutChaptersInput, subjectUncheckedUpdateWithoutChaptersInput>
    create: XOR<subjectCreateWithoutChaptersInput, subjectUncheckedCreateWithoutChaptersInput>
    where?: subjectWhereInput
  }

  export type subjectUpdateToOneWithWhereWithoutChaptersInput = {
    where?: subjectWhereInput
    data: XOR<subjectUpdateWithoutChaptersInput, subjectUncheckedUpdateWithoutChaptersInput>
  }

  export type subjectUpdateWithoutChaptersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUpdateManyWithoutSubjectNestedInput
    pdfs?: PdfUpdateManyWithoutSubjectNestedInput
    portion?: portionUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type subjectUncheckedUpdateWithoutChaptersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    portionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUncheckedUpdateManyWithoutSubjectNestedInput
    pdfs?: PdfUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type topicUpsertWithWhereUniqueWithoutChapterInput = {
    where: topicWhereUniqueInput
    update: XOR<topicUpdateWithoutChapterInput, topicUncheckedUpdateWithoutChapterInput>
    create: XOR<topicCreateWithoutChapterInput, topicUncheckedCreateWithoutChapterInput>
  }

  export type topicUpdateWithWhereUniqueWithoutChapterInput = {
    where: topicWhereUniqueInput
    data: XOR<topicUpdateWithoutChapterInput, topicUncheckedUpdateWithoutChapterInput>
  }

  export type topicUpdateManyWithWhereWithoutChapterInput = {
    where: topicScalarWhereInput
    data: XOR<topicUpdateManyMutationInput, topicUncheckedUpdateManyWithoutChapterInput>
  }

  export type topicScalarWhereInput = {
    AND?: topicScalarWhereInput | topicScalarWhereInput[]
    OR?: topicScalarWhereInput[]
    NOT?: topicScalarWhereInput | topicScalarWhereInput[]
    id?: IntFilter<"topic"> | number
    name?: StringFilter<"topic"> | string
    chapterId?: IntFilter<"topic"> | number
    createdAt?: DateTimeFilter<"topic"> | Date | string
  }

  export type questionCreateWithoutTopicInput = {
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
    questionType: questionTypeCreateNestedOneWithoutQuestionInput
    portion: portionCreateNestedOneWithoutQuestionsInput
    subject: subjectCreateNestedOneWithoutQuestionsInput
    chapter: chapterCreateNestedOneWithoutQuestionsInput
  }

  export type questionUncheckedCreateWithoutTopicInput = {
    id?: number
    questionTypeId: number
    portionId: number
    subjectId: number
    chapterId: number
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
  }

  export type questionCreateOrConnectWithoutTopicInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutTopicInput, questionUncheckedCreateWithoutTopicInput>
  }

  export type questionCreateManyTopicInputEnvelope = {
    data: questionCreateManyTopicInput | questionCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type PdfCreateWithoutTopicInput = {
    name: string
    url: string
    createdAt?: Date | string
    portion?: portionCreateNestedOneWithoutPdfsInput
    subject?: subjectCreateNestedOneWithoutPdfsInput
    chapter?: chapterCreateNestedOneWithoutPdfsInput
  }

  export type PdfUncheckedCreateWithoutTopicInput = {
    id?: number
    name: string
    url: string
    portionId?: number | null
    subjectId?: number | null
    chapterId?: number | null
    createdAt?: Date | string
  }

  export type PdfCreateOrConnectWithoutTopicInput = {
    where: PdfWhereUniqueInput
    create: XOR<PdfCreateWithoutTopicInput, PdfUncheckedCreateWithoutTopicInput>
  }

  export type PdfCreateManyTopicInputEnvelope = {
    data: PdfCreateManyTopicInput | PdfCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type chapterCreateWithoutTopicsInput = {
    name: string
    createdAt?: Date | string
    questions?: questionCreateNestedManyWithoutChapterInput
    pdfs?: PdfCreateNestedManyWithoutChapterInput
    subject: subjectCreateNestedOneWithoutChaptersInput
  }

  export type chapterUncheckedCreateWithoutTopicsInput = {
    id?: number
    name: string
    subjectId: number
    createdAt?: Date | string
    questions?: questionUncheckedCreateNestedManyWithoutChapterInput
    pdfs?: PdfUncheckedCreateNestedManyWithoutChapterInput
  }

  export type chapterCreateOrConnectWithoutTopicsInput = {
    where: chapterWhereUniqueInput
    create: XOR<chapterCreateWithoutTopicsInput, chapterUncheckedCreateWithoutTopicsInput>
  }

  export type questionUpsertWithWhereUniqueWithoutTopicInput = {
    where: questionWhereUniqueInput
    update: XOR<questionUpdateWithoutTopicInput, questionUncheckedUpdateWithoutTopicInput>
    create: XOR<questionCreateWithoutTopicInput, questionUncheckedCreateWithoutTopicInput>
  }

  export type questionUpdateWithWhereUniqueWithoutTopicInput = {
    where: questionWhereUniqueInput
    data: XOR<questionUpdateWithoutTopicInput, questionUncheckedUpdateWithoutTopicInput>
  }

  export type questionUpdateManyWithWhereWithoutTopicInput = {
    where: questionScalarWhereInput
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyWithoutTopicInput>
  }

  export type PdfUpsertWithWhereUniqueWithoutTopicInput = {
    where: PdfWhereUniqueInput
    update: XOR<PdfUpdateWithoutTopicInput, PdfUncheckedUpdateWithoutTopicInput>
    create: XOR<PdfCreateWithoutTopicInput, PdfUncheckedCreateWithoutTopicInput>
  }

  export type PdfUpdateWithWhereUniqueWithoutTopicInput = {
    where: PdfWhereUniqueInput
    data: XOR<PdfUpdateWithoutTopicInput, PdfUncheckedUpdateWithoutTopicInput>
  }

  export type PdfUpdateManyWithWhereWithoutTopicInput = {
    where: PdfScalarWhereInput
    data: XOR<PdfUpdateManyMutationInput, PdfUncheckedUpdateManyWithoutTopicInput>
  }

  export type chapterUpsertWithoutTopicsInput = {
    update: XOR<chapterUpdateWithoutTopicsInput, chapterUncheckedUpdateWithoutTopicsInput>
    create: XOR<chapterCreateWithoutTopicsInput, chapterUncheckedCreateWithoutTopicsInput>
    where?: chapterWhereInput
  }

  export type chapterUpdateToOneWithWhereWithoutTopicsInput = {
    where?: chapterWhereInput
    data: XOR<chapterUpdateWithoutTopicsInput, chapterUncheckedUpdateWithoutTopicsInput>
  }

  export type chapterUpdateWithoutTopicsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUpdateManyWithoutChapterNestedInput
    pdfs?: PdfUpdateManyWithoutChapterNestedInput
    subject?: subjectUpdateOneRequiredWithoutChaptersNestedInput
  }

  export type chapterUncheckedUpdateWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subjectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUncheckedUpdateManyWithoutChapterNestedInput
    pdfs?: PdfUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type questionTypeCreateWithoutQuestionInput = {
    name: string
    createdAt?: Date | string
    parent?: questionTypeCreateNestedOneWithoutOther_questionTypeInput
    other_questionType?: questionTypeCreateNestedManyWithoutParentInput
  }

  export type questionTypeUncheckedCreateWithoutQuestionInput = {
    id?: number
    name: string
    parentId?: number | null
    createdAt?: Date | string
    other_questionType?: questionTypeUncheckedCreateNestedManyWithoutParentInput
  }

  export type questionTypeCreateOrConnectWithoutQuestionInput = {
    where: questionTypeWhereUniqueInput
    create: XOR<questionTypeCreateWithoutQuestionInput, questionTypeUncheckedCreateWithoutQuestionInput>
  }

  export type portionCreateWithoutQuestionsInput = {
    name: string
    createdAt?: Date | string
    subjects?: subjectCreateNestedManyWithoutPortionInput
    pdfs?: PdfCreateNestedManyWithoutPortionInput
  }

  export type portionUncheckedCreateWithoutQuestionsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    subjects?: subjectUncheckedCreateNestedManyWithoutPortionInput
    pdfs?: PdfUncheckedCreateNestedManyWithoutPortionInput
  }

  export type portionCreateOrConnectWithoutQuestionsInput = {
    where: portionWhereUniqueInput
    create: XOR<portionCreateWithoutQuestionsInput, portionUncheckedCreateWithoutQuestionsInput>
  }

  export type subjectCreateWithoutQuestionsInput = {
    name: string
    createdAt?: Date | string
    chapters?: chapterCreateNestedManyWithoutSubjectInput
    pdfs?: PdfCreateNestedManyWithoutSubjectInput
    portion: portionCreateNestedOneWithoutSubjectsInput
  }

  export type subjectUncheckedCreateWithoutQuestionsInput = {
    id?: number
    name: string
    portionId: number
    createdAt?: Date | string
    chapters?: chapterUncheckedCreateNestedManyWithoutSubjectInput
    pdfs?: PdfUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectCreateOrConnectWithoutQuestionsInput = {
    where: subjectWhereUniqueInput
    create: XOR<subjectCreateWithoutQuestionsInput, subjectUncheckedCreateWithoutQuestionsInput>
  }

  export type chapterCreateWithoutQuestionsInput = {
    name: string
    createdAt?: Date | string
    pdfs?: PdfCreateNestedManyWithoutChapterInput
    subject: subjectCreateNestedOneWithoutChaptersInput
    topics?: topicCreateNestedManyWithoutChapterInput
  }

  export type chapterUncheckedCreateWithoutQuestionsInput = {
    id?: number
    name: string
    subjectId: number
    createdAt?: Date | string
    pdfs?: PdfUncheckedCreateNestedManyWithoutChapterInput
    topics?: topicUncheckedCreateNestedManyWithoutChapterInput
  }

  export type chapterCreateOrConnectWithoutQuestionsInput = {
    where: chapterWhereUniqueInput
    create: XOR<chapterCreateWithoutQuestionsInput, chapterUncheckedCreateWithoutQuestionsInput>
  }

  export type topicCreateWithoutQuestionsInput = {
    name: string
    createdAt?: Date | string
    pdfs?: PdfCreateNestedManyWithoutTopicInput
    chapter: chapterCreateNestedOneWithoutTopicsInput
  }

  export type topicUncheckedCreateWithoutQuestionsInput = {
    id?: number
    name: string
    chapterId: number
    createdAt?: Date | string
    pdfs?: PdfUncheckedCreateNestedManyWithoutTopicInput
  }

  export type topicCreateOrConnectWithoutQuestionsInput = {
    where: topicWhereUniqueInput
    create: XOR<topicCreateWithoutQuestionsInput, topicUncheckedCreateWithoutQuestionsInput>
  }

  export type questionTypeUpsertWithoutQuestionInput = {
    update: XOR<questionTypeUpdateWithoutQuestionInput, questionTypeUncheckedUpdateWithoutQuestionInput>
    create: XOR<questionTypeCreateWithoutQuestionInput, questionTypeUncheckedCreateWithoutQuestionInput>
    where?: questionTypeWhereInput
  }

  export type questionTypeUpdateToOneWithWhereWithoutQuestionInput = {
    where?: questionTypeWhereInput
    data: XOR<questionTypeUpdateWithoutQuestionInput, questionTypeUncheckedUpdateWithoutQuestionInput>
  }

  export type questionTypeUpdateWithoutQuestionInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: questionTypeUpdateOneWithoutOther_questionTypeNestedInput
    other_questionType?: questionTypeUpdateManyWithoutParentNestedInput
  }

  export type questionTypeUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    other_questionType?: questionTypeUncheckedUpdateManyWithoutParentNestedInput
  }

  export type portionUpsertWithoutQuestionsInput = {
    update: XOR<portionUpdateWithoutQuestionsInput, portionUncheckedUpdateWithoutQuestionsInput>
    create: XOR<portionCreateWithoutQuestionsInput, portionUncheckedCreateWithoutQuestionsInput>
    where?: portionWhereInput
  }

  export type portionUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: portionWhereInput
    data: XOR<portionUpdateWithoutQuestionsInput, portionUncheckedUpdateWithoutQuestionsInput>
  }

  export type portionUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: subjectUpdateManyWithoutPortionNestedInput
    pdfs?: PdfUpdateManyWithoutPortionNestedInput
  }

  export type portionUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: subjectUncheckedUpdateManyWithoutPortionNestedInput
    pdfs?: PdfUncheckedUpdateManyWithoutPortionNestedInput
  }

  export type subjectUpsertWithoutQuestionsInput = {
    update: XOR<subjectUpdateWithoutQuestionsInput, subjectUncheckedUpdateWithoutQuestionsInput>
    create: XOR<subjectCreateWithoutQuestionsInput, subjectUncheckedCreateWithoutQuestionsInput>
    where?: subjectWhereInput
  }

  export type subjectUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: subjectWhereInput
    data: XOR<subjectUpdateWithoutQuestionsInput, subjectUncheckedUpdateWithoutQuestionsInput>
  }

  export type subjectUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: chapterUpdateManyWithoutSubjectNestedInput
    pdfs?: PdfUpdateManyWithoutSubjectNestedInput
    portion?: portionUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type subjectUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    portionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: chapterUncheckedUpdateManyWithoutSubjectNestedInput
    pdfs?: PdfUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type chapterUpsertWithoutQuestionsInput = {
    update: XOR<chapterUpdateWithoutQuestionsInput, chapterUncheckedUpdateWithoutQuestionsInput>
    create: XOR<chapterCreateWithoutQuestionsInput, chapterUncheckedCreateWithoutQuestionsInput>
    where?: chapterWhereInput
  }

  export type chapterUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: chapterWhereInput
    data: XOR<chapterUpdateWithoutQuestionsInput, chapterUncheckedUpdateWithoutQuestionsInput>
  }

  export type chapterUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfs?: PdfUpdateManyWithoutChapterNestedInput
    subject?: subjectUpdateOneRequiredWithoutChaptersNestedInput
    topics?: topicUpdateManyWithoutChapterNestedInput
  }

  export type chapterUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subjectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfs?: PdfUncheckedUpdateManyWithoutChapterNestedInput
    topics?: topicUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type topicUpsertWithoutQuestionsInput = {
    update: XOR<topicUpdateWithoutQuestionsInput, topicUncheckedUpdateWithoutQuestionsInput>
    create: XOR<topicCreateWithoutQuestionsInput, topicUncheckedCreateWithoutQuestionsInput>
    where?: topicWhereInput
  }

  export type topicUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: topicWhereInput
    data: XOR<topicUpdateWithoutQuestionsInput, topicUncheckedUpdateWithoutQuestionsInput>
  }

  export type topicUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfs?: PdfUpdateManyWithoutTopicNestedInput
    chapter?: chapterUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type topicUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    chapterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfs?: PdfUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type portionCreateWithoutPdfsInput = {
    name: string
    createdAt?: Date | string
    subjects?: subjectCreateNestedManyWithoutPortionInput
    questions?: questionCreateNestedManyWithoutPortionInput
  }

  export type portionUncheckedCreateWithoutPdfsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    subjects?: subjectUncheckedCreateNestedManyWithoutPortionInput
    questions?: questionUncheckedCreateNestedManyWithoutPortionInput
  }

  export type portionCreateOrConnectWithoutPdfsInput = {
    where: portionWhereUniqueInput
    create: XOR<portionCreateWithoutPdfsInput, portionUncheckedCreateWithoutPdfsInput>
  }

  export type subjectCreateWithoutPdfsInput = {
    name: string
    createdAt?: Date | string
    chapters?: chapterCreateNestedManyWithoutSubjectInput
    questions?: questionCreateNestedManyWithoutSubjectInput
    portion: portionCreateNestedOneWithoutSubjectsInput
  }

  export type subjectUncheckedCreateWithoutPdfsInput = {
    id?: number
    name: string
    portionId: number
    createdAt?: Date | string
    chapters?: chapterUncheckedCreateNestedManyWithoutSubjectInput
    questions?: questionUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectCreateOrConnectWithoutPdfsInput = {
    where: subjectWhereUniqueInput
    create: XOR<subjectCreateWithoutPdfsInput, subjectUncheckedCreateWithoutPdfsInput>
  }

  export type chapterCreateWithoutPdfsInput = {
    name: string
    createdAt?: Date | string
    questions?: questionCreateNestedManyWithoutChapterInput
    subject: subjectCreateNestedOneWithoutChaptersInput
    topics?: topicCreateNestedManyWithoutChapterInput
  }

  export type chapterUncheckedCreateWithoutPdfsInput = {
    id?: number
    name: string
    subjectId: number
    createdAt?: Date | string
    questions?: questionUncheckedCreateNestedManyWithoutChapterInput
    topics?: topicUncheckedCreateNestedManyWithoutChapterInput
  }

  export type chapterCreateOrConnectWithoutPdfsInput = {
    where: chapterWhereUniqueInput
    create: XOR<chapterCreateWithoutPdfsInput, chapterUncheckedCreateWithoutPdfsInput>
  }

  export type topicCreateWithoutPdfsInput = {
    name: string
    createdAt?: Date | string
    questions?: questionCreateNestedManyWithoutTopicInput
    chapter: chapterCreateNestedOneWithoutTopicsInput
  }

  export type topicUncheckedCreateWithoutPdfsInput = {
    id?: number
    name: string
    chapterId: number
    createdAt?: Date | string
    questions?: questionUncheckedCreateNestedManyWithoutTopicInput
  }

  export type topicCreateOrConnectWithoutPdfsInput = {
    where: topicWhereUniqueInput
    create: XOR<topicCreateWithoutPdfsInput, topicUncheckedCreateWithoutPdfsInput>
  }

  export type portionUpsertWithoutPdfsInput = {
    update: XOR<portionUpdateWithoutPdfsInput, portionUncheckedUpdateWithoutPdfsInput>
    create: XOR<portionCreateWithoutPdfsInput, portionUncheckedCreateWithoutPdfsInput>
    where?: portionWhereInput
  }

  export type portionUpdateToOneWithWhereWithoutPdfsInput = {
    where?: portionWhereInput
    data: XOR<portionUpdateWithoutPdfsInput, portionUncheckedUpdateWithoutPdfsInput>
  }

  export type portionUpdateWithoutPdfsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: subjectUpdateManyWithoutPortionNestedInput
    questions?: questionUpdateManyWithoutPortionNestedInput
  }

  export type portionUncheckedUpdateWithoutPdfsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: subjectUncheckedUpdateManyWithoutPortionNestedInput
    questions?: questionUncheckedUpdateManyWithoutPortionNestedInput
  }

  export type subjectUpsertWithoutPdfsInput = {
    update: XOR<subjectUpdateWithoutPdfsInput, subjectUncheckedUpdateWithoutPdfsInput>
    create: XOR<subjectCreateWithoutPdfsInput, subjectUncheckedCreateWithoutPdfsInput>
    where?: subjectWhereInput
  }

  export type subjectUpdateToOneWithWhereWithoutPdfsInput = {
    where?: subjectWhereInput
    data: XOR<subjectUpdateWithoutPdfsInput, subjectUncheckedUpdateWithoutPdfsInput>
  }

  export type subjectUpdateWithoutPdfsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: chapterUpdateManyWithoutSubjectNestedInput
    questions?: questionUpdateManyWithoutSubjectNestedInput
    portion?: portionUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type subjectUncheckedUpdateWithoutPdfsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    portionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: chapterUncheckedUpdateManyWithoutSubjectNestedInput
    questions?: questionUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type chapterUpsertWithoutPdfsInput = {
    update: XOR<chapterUpdateWithoutPdfsInput, chapterUncheckedUpdateWithoutPdfsInput>
    create: XOR<chapterCreateWithoutPdfsInput, chapterUncheckedCreateWithoutPdfsInput>
    where?: chapterWhereInput
  }

  export type chapterUpdateToOneWithWhereWithoutPdfsInput = {
    where?: chapterWhereInput
    data: XOR<chapterUpdateWithoutPdfsInput, chapterUncheckedUpdateWithoutPdfsInput>
  }

  export type chapterUpdateWithoutPdfsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUpdateManyWithoutChapterNestedInput
    subject?: subjectUpdateOneRequiredWithoutChaptersNestedInput
    topics?: topicUpdateManyWithoutChapterNestedInput
  }

  export type chapterUncheckedUpdateWithoutPdfsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subjectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUncheckedUpdateManyWithoutChapterNestedInput
    topics?: topicUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type topicUpsertWithoutPdfsInput = {
    update: XOR<topicUpdateWithoutPdfsInput, topicUncheckedUpdateWithoutPdfsInput>
    create: XOR<topicCreateWithoutPdfsInput, topicUncheckedCreateWithoutPdfsInput>
    where?: topicWhereInput
  }

  export type topicUpdateToOneWithWhereWithoutPdfsInput = {
    where?: topicWhereInput
    data: XOR<topicUpdateWithoutPdfsInput, topicUncheckedUpdateWithoutPdfsInput>
  }

  export type topicUpdateWithoutPdfsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUpdateManyWithoutTopicNestedInput
    chapter?: chapterUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type topicUncheckedUpdateWithoutPdfsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    chapterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type UserCreateWithoutTestResultsInput = {
    email: string
    name?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    age?: number | null
    gender?: string | null
    profile?: string | null
  }

  export type UserUncheckedCreateWithoutTestResultsInput = {
    id?: number
    email: string
    name?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    age?: number | null
    gender?: string | null
    profile?: string | null
  }

  export type UserCreateOrConnectWithoutTestResultsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestResultsInput, UserUncheckedCreateWithoutTestResultsInput>
  }

  export type UserUpsertWithoutTestResultsInput = {
    update: XOR<UserUpdateWithoutTestResultsInput, UserUncheckedUpdateWithoutTestResultsInput>
    create: XOR<UserCreateWithoutTestResultsInput, UserUncheckedCreateWithoutTestResultsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestResultsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestResultsInput, UserUncheckedUpdateWithoutTestResultsInput>
  }

  export type UserUpdateWithoutTestResultsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateWithoutTestResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestResultCreateManyUserInput = {
    id?: number
    score: number
    totalMarks: number
    answered: number
    correct: number
    wrong: number
    unanswered: number
    accuracy: number
    totalTimeTaken: number
    resultsByType: JsonNullValueInput | InputJsonValue
    resultsByChapter: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TestResultUpdateWithoutUserInput = {
    score?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    answered?: IntFieldUpdateOperationsInput | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    totalTimeTaken?: IntFieldUpdateOperationsInput | number
    resultsByType?: JsonNullValueInput | InputJsonValue
    resultsByChapter?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    answered?: IntFieldUpdateOperationsInput | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    totalTimeTaken?: IntFieldUpdateOperationsInput | number
    resultsByType?: JsonNullValueInput | InputJsonValue
    resultsByChapter?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    answered?: IntFieldUpdateOperationsInput | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    totalTimeTaken?: IntFieldUpdateOperationsInput | number
    resultsByType?: JsonNullValueInput | InputJsonValue
    resultsByChapter?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionTypeCreateManyParentInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type questionCreateManyQuestionTypeInput = {
    id?: number
    portionId: number
    subjectId: number
    chapterId: number
    topicId: number
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
  }

  export type questionTypeUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    other_questionType?: questionTypeUpdateManyWithoutParentNestedInput
    question?: questionUpdateManyWithoutQuestionTypeNestedInput
  }

  export type questionTypeUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    other_questionType?: questionTypeUncheckedUpdateManyWithoutParentNestedInput
    question?: questionUncheckedUpdateManyWithoutQuestionTypeNestedInput
  }

  export type questionTypeUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionUpdateWithoutQuestionTypeInput = {
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portion?: portionUpdateOneRequiredWithoutQuestionsNestedInput
    subject?: subjectUpdateOneRequiredWithoutQuestionsNestedInput
    chapter?: chapterUpdateOneRequiredWithoutQuestionsNestedInput
    topic?: topicUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type questionUncheckedUpdateWithoutQuestionTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    portionId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionUncheckedUpdateManyWithoutQuestionTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    portionId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectCreateManyPortionInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type questionCreateManyPortionInput = {
    id?: number
    questionTypeId: number
    subjectId: number
    chapterId: number
    topicId: number
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
  }

  export type PdfCreateManyPortionInput = {
    id?: number
    name: string
    url: string
    subjectId?: number | null
    chapterId?: number | null
    topicId?: number | null
    createdAt?: Date | string
  }

  export type subjectUpdateWithoutPortionInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: chapterUpdateManyWithoutSubjectNestedInput
    questions?: questionUpdateManyWithoutSubjectNestedInput
    pdfs?: PdfUpdateManyWithoutSubjectNestedInput
  }

  export type subjectUncheckedUpdateWithoutPortionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: chapterUncheckedUpdateManyWithoutSubjectNestedInput
    questions?: questionUncheckedUpdateManyWithoutSubjectNestedInput
    pdfs?: PdfUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type subjectUncheckedUpdateManyWithoutPortionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionUpdateWithoutPortionInput = {
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionType?: questionTypeUpdateOneRequiredWithoutQuestionNestedInput
    subject?: subjectUpdateOneRequiredWithoutQuestionsNestedInput
    chapter?: chapterUpdateOneRequiredWithoutQuestionsNestedInput
    topic?: topicUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type questionUncheckedUpdateWithoutPortionInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionTypeId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionUncheckedUpdateManyWithoutPortionInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionTypeId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfUpdateWithoutPortionInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: subjectUpdateOneWithoutPdfsNestedInput
    chapter?: chapterUpdateOneWithoutPdfsNestedInput
    topic?: topicUpdateOneWithoutPdfsNestedInput
  }

  export type PdfUncheckedUpdateWithoutPortionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfUncheckedUpdateManyWithoutPortionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chapterCreateManySubjectInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type questionCreateManySubjectInput = {
    id?: number
    questionTypeId: number
    portionId: number
    chapterId: number
    topicId: number
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
  }

  export type PdfCreateManySubjectInput = {
    id?: number
    name: string
    url: string
    portionId?: number | null
    chapterId?: number | null
    topicId?: number | null
    createdAt?: Date | string
  }

  export type chapterUpdateWithoutSubjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUpdateManyWithoutChapterNestedInput
    pdfs?: PdfUpdateManyWithoutChapterNestedInput
    topics?: topicUpdateManyWithoutChapterNestedInput
  }

  export type chapterUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUncheckedUpdateManyWithoutChapterNestedInput
    pdfs?: PdfUncheckedUpdateManyWithoutChapterNestedInput
    topics?: topicUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type chapterUncheckedUpdateManyWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionUpdateWithoutSubjectInput = {
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionType?: questionTypeUpdateOneRequiredWithoutQuestionNestedInput
    portion?: portionUpdateOneRequiredWithoutQuestionsNestedInput
    chapter?: chapterUpdateOneRequiredWithoutQuestionsNestedInput
    topic?: topicUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type questionUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionTypeId?: IntFieldUpdateOperationsInput | number
    portionId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionUncheckedUpdateManyWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionTypeId?: IntFieldUpdateOperationsInput | number
    portionId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfUpdateWithoutSubjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portion?: portionUpdateOneWithoutPdfsNestedInput
    chapter?: chapterUpdateOneWithoutPdfsNestedInput
    topic?: topicUpdateOneWithoutPdfsNestedInput
  }

  export type PdfUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    portionId?: NullableIntFieldUpdateOperationsInput | number | null
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfUncheckedUpdateManyWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    portionId?: NullableIntFieldUpdateOperationsInput | number | null
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionCreateManyChapterInput = {
    id?: number
    questionTypeId: number
    portionId: number
    subjectId: number
    topicId: number
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
  }

  export type PdfCreateManyChapterInput = {
    id?: number
    name: string
    url: string
    portionId?: number | null
    subjectId?: number | null
    topicId?: number | null
    createdAt?: Date | string
  }

  export type topicCreateManyChapterInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type questionUpdateWithoutChapterInput = {
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionType?: questionTypeUpdateOneRequiredWithoutQuestionNestedInput
    portion?: portionUpdateOneRequiredWithoutQuestionsNestedInput
    subject?: subjectUpdateOneRequiredWithoutQuestionsNestedInput
    topic?: topicUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type questionUncheckedUpdateWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionTypeId?: IntFieldUpdateOperationsInput | number
    portionId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionUncheckedUpdateManyWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionTypeId?: IntFieldUpdateOperationsInput | number
    portionId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfUpdateWithoutChapterInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portion?: portionUpdateOneWithoutPdfsNestedInput
    subject?: subjectUpdateOneWithoutPdfsNestedInput
    topic?: topicUpdateOneWithoutPdfsNestedInput
  }

  export type PdfUncheckedUpdateWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    portionId?: NullableIntFieldUpdateOperationsInput | number | null
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfUncheckedUpdateManyWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    portionId?: NullableIntFieldUpdateOperationsInput | number | null
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type topicUpdateWithoutChapterInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUpdateManyWithoutTopicNestedInput
    pdfs?: PdfUpdateManyWithoutTopicNestedInput
  }

  export type topicUncheckedUpdateWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionUncheckedUpdateManyWithoutTopicNestedInput
    pdfs?: PdfUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type topicUncheckedUpdateManyWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionCreateManyTopicInput = {
    id?: number
    questionTypeId: number
    portionId: number
    subjectId: number
    chapterId: number
    question: string
    image?: string | null
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    hint?: string | null
    hintImage?: string | null
    createdAt?: Date | string
  }

  export type PdfCreateManyTopicInput = {
    id?: number
    name: string
    url: string
    portionId?: number | null
    subjectId?: number | null
    chapterId?: number | null
    createdAt?: Date | string
  }

  export type questionUpdateWithoutTopicInput = {
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionType?: questionTypeUpdateOneRequiredWithoutQuestionNestedInput
    portion?: portionUpdateOneRequiredWithoutQuestionsNestedInput
    subject?: subjectUpdateOneRequiredWithoutQuestionsNestedInput
    chapter?: chapterUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type questionUncheckedUpdateWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionTypeId?: IntFieldUpdateOperationsInput | number
    portionId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionUncheckedUpdateManyWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionTypeId?: IntFieldUpdateOperationsInput | number
    portionId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfUpdateWithoutTopicInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portion?: portionUpdateOneWithoutPdfsNestedInput
    subject?: subjectUpdateOneWithoutPdfsNestedInput
    chapter?: chapterUpdateOneWithoutPdfsNestedInput
  }

  export type PdfUncheckedUpdateWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    portionId?: NullableIntFieldUpdateOperationsInput | number | null
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfUncheckedUpdateManyWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    portionId?: NullableIntFieldUpdateOperationsInput | number | null
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}